{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kusama-utils Kusama utility library providing functionality for multi-signature trading Pre-requisites Python 3.8.1 (preferred) We suggest using pyenv to easily manage python versions. Some of the following commands use pyenv . Use pyenv-installer for easy installation. Then add pyenv-virtualenv plugin to it. Configure local development setup Install and activate python 3.8.1 in the root directory pyenv install 3.8.1 pyenv virtualenv 3.8.1 ksmutils pyenv local ksmutils Install project requirements pip install -r requirements.txt Install precommit hook pre-commit install You're all set to hack! Before making changes, let's ensure tests run successfully on local. Running Tests Run all tests with coverage coverage run -m pytest -v Show report in terminal coverage report -m","title":"Home"},{"location":"#kusama-utils","text":"Kusama utility library providing functionality for multi-signature trading","title":"kusama-utils"},{"location":"#pre-requisites","text":"Python 3.8.1 (preferred) We suggest using pyenv to easily manage python versions. Some of the following commands use pyenv . Use pyenv-installer for easy installation. Then add pyenv-virtualenv plugin to it.","title":"Pre-requisites"},{"location":"#configure-local-development-setup","text":"Install and activate python 3.8.1 in the root directory pyenv install 3.8.1 pyenv virtualenv 3.8.1 ksmutils pyenv local ksmutils Install project requirements pip install -r requirements.txt Install precommit hook pre-commit install You're all set to hack! Before making changes, let's ensure tests run successfully on local.","title":"Configure local development setup"},{"location":"#running-tests","text":"Run all tests with coverage coverage run -m pytest -v Show report in terminal coverage report -m","title":"Running Tests"},{"location":"docs/contributing/1.-local-development/","text":"Local Development Checklist before publishing the package Make sure to update REQUIRED and EXTRAS lists in setup.py based on what's required by the library and what's required only for development. To ease local development, we will continue to maintain requirements.txt which includes every package. Bump the version constant VERSION in setup.py Run setup test python setup.py test Publish package to PyPI python setup.py upload Generating Documentation Generate on local for testing portray server Publishing the docs to https://localcoinswap.github.io/kusama-utils/ Please make sure the docs look as expected on local Checkout to docs-branch branch Only difference between master and docs-branch is that the site/ is not gitignored in docs-branch Rebase docs-branch with master Run portray as_html --overwrite (Read portray docs to know more) That will generate html docs in site/ directory, it will overwrite the existing content Commit the changes and push to docs-branch (Use --force since we rebased with master ) Run this nested git command to publish the changes in gh-pages branch (which serves the static html) git push origin `git subtree split --prefix site docs-branch`:gh-pages --force","title":"1. Local Development"},{"location":"docs/contributing/1.-local-development/#local-development","text":"","title":"Local Development"},{"location":"docs/contributing/1.-local-development/#checklist-before-publishing-the-package","text":"Make sure to update REQUIRED and EXTRAS lists in setup.py based on what's required by the library and what's required only for development. To ease local development, we will continue to maintain requirements.txt which includes every package. Bump the version constant VERSION in setup.py Run setup test python setup.py test Publish package to PyPI python setup.py upload","title":"Checklist before publishing the package"},{"location":"docs/contributing/1.-local-development/#generating-documentation","text":"Generate on local for testing portray server Publishing the docs to https://localcoinswap.github.io/kusama-utils/ Please make sure the docs look as expected on local Checkout to docs-branch branch Only difference between master and docs-branch is that the site/ is not gitignored in docs-branch Rebase docs-branch with master Run portray as_html --overwrite (Read portray docs to know more) That will generate html docs in site/ directory, it will overwrite the existing content Commit the changes and push to docs-branch (Use --force since we rebased with master ) Run this nested git command to publish the changes in gh-pages branch (which serves the static html) git push origin `git subtree split --prefix site docs-branch`:gh-pages --force","title":"Generating Documentation"},{"location":"reference/ksmutils/","text":"Module ksmutils View Source from .core import Kusama from .logging import Logger from .logging import PyTestLogger from .network import Network __all__ = [ Kusama , Logger , PyTestLogger , Network ] Sub-modules ksmutils.core ksmutils.helper ksmutils.logging ksmutils.network ksmutils.settings","title":"Index"},{"location":"reference/ksmutils/#module-ksmutils","text":"View Source from .core import Kusama from .logging import Logger from .logging import PyTestLogger from .network import Network __all__ = [ Kusama , Logger , PyTestLogger , Network ]","title":"Module ksmutils"},{"location":"reference/ksmutils/#sub-modules","text":"ksmutils.core ksmutils.helper ksmutils.logging ksmutils.network ksmutils.settings","title":"Sub-modules"},{"location":"reference/ksmutils/core/","text":"Module ksmutils.core View Source from hashlib import blake2b from scalecodec import ScaleBytes from scalecodec.base import RuntimeConfiguration from scalecodec.base import ScaleDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.type_registry import load_type_registry_preset from scalecodec.utils.ss58 import ss58_decode from .logging import Logger from .network import Network # Hardcode this because we WANT things to break if it changes BLOCKCHAIN_VERSION = 1062 class Kusama : def __init__ ( self , * , address : str = \"wss://kusama-rpc.polkadot.io/\" , logger : \"Logger\" = Logger , ): self . address = address self . logger = logger def connect ( self , * , logger : \"Logger\" = None , address : str = \"\" , network : \"Network\" = None ): logger = self . logger if not logger else logger address = self . address if not address else address if not network : network = Network ( logger = logger , address = address ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION # WARNING: Relying on side effects to run code is dangerous, refactor this if possible RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def check_version ( self ): \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [], loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] def get_metadata ( self ): raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ], loop_limit = 1 )[ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ): return BLOCKCHAIN_VERSION def get_genesis_hash ( self ): return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ], loop_limit = 1 )[ 0 ][ \"result\" ] def _get_address_info ( self , address ): # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ], loop_limit = 1 )[ 0 ][ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address ): result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address ): result = self . _get_address_info ( address ) return result [ \"nonce\" ] def broadcast_extrinsic ( self ): \"\"\" Raw extrinsic broadcast \"\"\" pass def broadcast ( self ): \"\"\" Handles final transaction construction according to transaction type \"\"\" pass def unsigned_transfer ( self ): \"\"\" Unsigned transfer endpoint \"\"\" pass def create_escrow ( self ): \"\"\" Get unsigned escrow transactions \"\"\" pass Variables BLOCKCHAIN_VERSION Classes Kusama class Kusama ( * , address : str = 'wss://kusama-rpc.polkadot.io/' , logger : 'Logger' = < class ' ksmutils . logging . Logger '> ) View Source class Kusama : def __init__ ( self , * , address : str = \"wss://kusama-rpc.polkadot.io/\" , logger : \"Logger\" = Logger , ) : self . address = address self . logger = logger def connect ( self , * , logger : \"Logger\" = None , address : str = \"\" , network : \"Network\" = None ) : logger = self . logger if not logger else logger address = self . address if not address else address if not network : network = Network ( logger = logger , address = address ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION # WARNING : Relying on side effects to run code is dangerous , refactor this if possible RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def check_version ( self ) : \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [] , loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] def get_metadata ( self ) : raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ) : return BLOCKCHAIN_VERSION def get_genesis_hash ( self ) : return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ] , loop_limit = 1 ) [ 0 ][ \"result\" ] def _get_address_info ( self , address ) : # xxHash128 ( System ) + xxHash128 ( Account ) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash, None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address ) : result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address ) : result = self . _get_address_info ( address ) return result [ \"nonce\" ] def broadcast_extrinsic ( self ) : \"\"\" Raw extrinsic broadcast \"\"\" pass def broadcast ( self ) : \"\"\" Handles final transaction construction according to transaction type \"\"\" pass def unsigned_transfer ( self ) : \"\"\" Unsigned transfer endpoint \"\"\" pass def create_escrow ( self ) : \"\"\" Get unsigned escrow transactions \"\"\" pass Methods broadcast def broadcast ( self ) Handles final transaction construction according to transaction type View Source def broadcast ( self ): \"\"\" Handles final transaction construction according to transaction type \"\"\" pass broadcast_extrinsic def broadcast_extrinsic ( self ) Raw extrinsic broadcast View Source def broadcast_extrinsic ( self ): \"\"\" Raw extrinsic broadcast \"\"\" pass check_version def check_version ( self ) Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase View Source def check_version ( self ): \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [], loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] connect def connect ( self , * , logger : 'Logger' = None , address : str = '' , network : 'Network' = None ) View Source def connect ( self , * , logger : \"Logger\" = None , address : str = \"\" , network : \"Network\" = None ): logger = self . logger if not logger else logger address = self . address if not address else address if not network : network = Network ( logger = logger , address = address ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION # WARNING : Relying on side effects to run code is dangerous , refactor this if possible RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () create_escrow def create_escrow ( self ) Get unsigned escrow transactions View Source def create_escrow ( self ): \"\"\" Get unsigned escrow transactions \"\"\" pass get_balance def get_balance ( self , address ) View Source def get_balance ( self , address ): result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] get_genesis_hash def get_genesis_hash ( self ) View Source def get_genesis_hash ( self ): return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ], loop_limit = 1 )[ 0 ][ \"result\" ] get_metadata def get_metadata ( self ) View Source def get_metadata ( self ) : raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata get_nonce def get_nonce ( self , address ) View Source def get_nonce ( self , address ): result = self . _get_address_info ( address ) return result [ \"nonce\" ] get_spec_version def get_spec_version ( self ) View Source def get_spec_version ( self ): return BLOCKCHAIN_VERSION unsigned_transfer def unsigned_transfer ( self ) Unsigned transfer endpoint View Source def unsigned_transfer ( self ): \"\"\" Unsigned transfer endpoint \"\"\" pass","title":"Core"},{"location":"reference/ksmutils/core/#module-ksmutilscore","text":"View Source from hashlib import blake2b from scalecodec import ScaleBytes from scalecodec.base import RuntimeConfiguration from scalecodec.base import ScaleDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.type_registry import load_type_registry_preset from scalecodec.utils.ss58 import ss58_decode from .logging import Logger from .network import Network # Hardcode this because we WANT things to break if it changes BLOCKCHAIN_VERSION = 1062 class Kusama : def __init__ ( self , * , address : str = \"wss://kusama-rpc.polkadot.io/\" , logger : \"Logger\" = Logger , ): self . address = address self . logger = logger def connect ( self , * , logger : \"Logger\" = None , address : str = \"\" , network : \"Network\" = None ): logger = self . logger if not logger else logger address = self . address if not address else address if not network : network = Network ( logger = logger , address = address ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION # WARNING: Relying on side effects to run code is dangerous, refactor this if possible RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def check_version ( self ): \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [], loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] def get_metadata ( self ): raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ], loop_limit = 1 )[ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ): return BLOCKCHAIN_VERSION def get_genesis_hash ( self ): return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ], loop_limit = 1 )[ 0 ][ \"result\" ] def _get_address_info ( self , address ): # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ], loop_limit = 1 )[ 0 ][ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address ): result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address ): result = self . _get_address_info ( address ) return result [ \"nonce\" ] def broadcast_extrinsic ( self ): \"\"\" Raw extrinsic broadcast \"\"\" pass def broadcast ( self ): \"\"\" Handles final transaction construction according to transaction type \"\"\" pass def unsigned_transfer ( self ): \"\"\" Unsigned transfer endpoint \"\"\" pass def create_escrow ( self ): \"\"\" Get unsigned escrow transactions \"\"\" pass","title":"Module ksmutils.core"},{"location":"reference/ksmutils/core/#variables","text":"BLOCKCHAIN_VERSION","title":"Variables"},{"location":"reference/ksmutils/core/#classes","text":"","title":"Classes"},{"location":"reference/ksmutils/core/#kusama","text":"class Kusama ( * , address : str = 'wss://kusama-rpc.polkadot.io/' , logger : 'Logger' = < class ' ksmutils . logging . Logger '> ) View Source class Kusama : def __init__ ( self , * , address : str = \"wss://kusama-rpc.polkadot.io/\" , logger : \"Logger\" = Logger , ) : self . address = address self . logger = logger def connect ( self , * , logger : \"Logger\" = None , address : str = \"\" , network : \"Network\" = None ) : logger = self . logger if not logger else logger address = self . address if not address else address if not network : network = Network ( logger = logger , address = address ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION # WARNING : Relying on side effects to run code is dangerous , refactor this if possible RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def check_version ( self ) : \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [] , loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] def get_metadata ( self ) : raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ) : return BLOCKCHAIN_VERSION def get_genesis_hash ( self ) : return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ] , loop_limit = 1 ) [ 0 ][ \"result\" ] def _get_address_info ( self , address ) : # xxHash128 ( System ) + xxHash128 ( Account ) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash, None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address ) : result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address ) : result = self . _get_address_info ( address ) return result [ \"nonce\" ] def broadcast_extrinsic ( self ) : \"\"\" Raw extrinsic broadcast \"\"\" pass def broadcast ( self ) : \"\"\" Handles final transaction construction according to transaction type \"\"\" pass def unsigned_transfer ( self ) : \"\"\" Unsigned transfer endpoint \"\"\" pass def create_escrow ( self ) : \"\"\" Get unsigned escrow transactions \"\"\" pass","title":"Kusama"},{"location":"reference/ksmutils/core/#methods","text":"","title":"Methods"},{"location":"reference/ksmutils/core/#broadcast","text":"def broadcast ( self ) Handles final transaction construction according to transaction type View Source def broadcast ( self ): \"\"\" Handles final transaction construction according to transaction type \"\"\" pass","title":"broadcast"},{"location":"reference/ksmutils/core/#broadcast_extrinsic","text":"def broadcast_extrinsic ( self ) Raw extrinsic broadcast View Source def broadcast_extrinsic ( self ): \"\"\" Raw extrinsic broadcast \"\"\" pass","title":"broadcast_extrinsic"},{"location":"reference/ksmutils/core/#check_version","text":"def check_version ( self ) Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase View Source def check_version ( self ): \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [], loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ]","title":"check_version"},{"location":"reference/ksmutils/core/#connect","text":"def connect ( self , * , logger : 'Logger' = None , address : str = '' , network : 'Network' = None ) View Source def connect ( self , * , logger : \"Logger\" = None , address : str = \"\" , network : \"Network\" = None ): logger = self . logger if not logger else logger address = self . address if not address else address if not network : network = Network ( logger = logger , address = address ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION # WARNING : Relying on side effects to run code is dangerous , refactor this if possible RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash ()","title":"connect"},{"location":"reference/ksmutils/core/#create_escrow","text":"def create_escrow ( self ) Get unsigned escrow transactions View Source def create_escrow ( self ): \"\"\" Get unsigned escrow transactions \"\"\" pass","title":"create_escrow"},{"location":"reference/ksmutils/core/#get_balance","text":"def get_balance ( self , address ) View Source def get_balance ( self , address ): result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ]","title":"get_balance"},{"location":"reference/ksmutils/core/#get_genesis_hash","text":"def get_genesis_hash ( self ) View Source def get_genesis_hash ( self ): return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ], loop_limit = 1 )[ 0 ][ \"result\" ]","title":"get_genesis_hash"},{"location":"reference/ksmutils/core/#get_metadata","text":"def get_metadata ( self ) View Source def get_metadata ( self ) : raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata","title":"get_metadata"},{"location":"reference/ksmutils/core/#get_nonce","text":"def get_nonce ( self , address ) View Source def get_nonce ( self , address ): result = self . _get_address_info ( address ) return result [ \"nonce\" ]","title":"get_nonce"},{"location":"reference/ksmutils/core/#get_spec_version","text":"def get_spec_version ( self ) View Source def get_spec_version ( self ): return BLOCKCHAIN_VERSION","title":"get_spec_version"},{"location":"reference/ksmutils/core/#unsigned_transfer","text":"def unsigned_transfer ( self ) Unsigned transfer endpoint View Source def unsigned_transfer ( self ): \"\"\" Unsigned transfer endpoint \"\"\" pass","title":"unsigned_transfer"},{"location":"reference/ksmutils/helper/","text":"Module ksmutils.helper Helper functions - all functions in this file are pure with no side effects View Source \"\"\" Helper functions - all functions in this file are pure with no side effects \"\"\" from hashlib import blake2b from scalecodec.base import ScaleDecoder def hash_call ( call ): call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ): \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) approve_as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip = 0 , ): extrinsic = ScaleDecoder . get_decoder_class ( \"Extrinsic\" , metadata = metadata ) extrinsic . encode ( { \"account_id\" : account_id , \"signature_version\" : 1 , \"signature\" : signature , \"call_function\" : call_function , \"call_module\" : call_module , \"call_args\" : call_arguments , \"nonce\" : nonce , \"era\" : \"00\" , \"tip\" : tip , } ) return str ( extrinsic . data ) def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ): call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"approve_as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) Functions approve_as_multi_signature_payload def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 ) View Source def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) approve_as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) as_multi_signature_payload def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 ) View Source def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) hash_call def hash_call ( call ) View Source def hash_call ( call ): call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" transfer_signature_payload def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ) Turn parameters gathered through side effects into unsigned transfer string View Source def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ): \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) unsigned_approve_as_multi_construction def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 ) View Source def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"approve_as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) unsigned_as_multi_construction def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 ) View Source def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) unsigned_transfer_construction def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ) View Source def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ): call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"Helper"},{"location":"reference/ksmutils/helper/#module-ksmutilshelper","text":"Helper functions - all functions in this file are pure with no side effects View Source \"\"\" Helper functions - all functions in this file are pure with no side effects \"\"\" from hashlib import blake2b from scalecodec.base import ScaleDecoder def hash_call ( call ): call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ): \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) approve_as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip = 0 , ): extrinsic = ScaleDecoder . get_decoder_class ( \"Extrinsic\" , metadata = metadata ) extrinsic . encode ( { \"account_id\" : account_id , \"signature_version\" : 1 , \"signature\" : signature , \"call_function\" : call_function , \"call_module\" : call_module , \"call_args\" : call_arguments , \"nonce\" : nonce , \"era\" : \"00\" , \"tip\" : tip , } ) return str ( extrinsic . data ) def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ): call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"approve_as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"Module ksmutils.helper"},{"location":"reference/ksmutils/helper/#functions","text":"","title":"Functions"},{"location":"reference/ksmutils/helper/#approve_as_multi_signature_payload","text":"def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 ) View Source def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) approve_as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"approve_as_multi_signature_payload"},{"location":"reference/ksmutils/helper/#as_multi_signature_payload","text":"def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 ) View Source def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"as_multi_signature_payload"},{"location":"reference/ksmutils/helper/#hash_call","text":"def hash_call ( call ) View Source def hash_call ( call ): call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\"","title":"hash_call"},{"location":"reference/ksmutils/helper/#transfer_signature_payload","text":"def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ) Turn parameters gathered through side effects into unsigned transfer string View Source def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ): \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"transfer_signature_payload"},{"location":"reference/ksmutils/helper/#unsigned_approve_as_multi_construction","text":"def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 ) View Source def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"approve_as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"unsigned_approve_as_multi_construction"},{"location":"reference/ksmutils/helper/#unsigned_as_multi_construction","text":"def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 ) View Source def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"unsigned_as_multi_construction"},{"location":"reference/ksmutils/helper/#unsigned_transfer_construction","text":"def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ) View Source def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ): call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"unsigned_transfer_construction"},{"location":"reference/ksmutils/logging/","text":"Module ksmutils.logging View Source import logging class Logger : def __init__ ( self ): kusama_logger = logging . getLogger ( \"kusama\" ) kusama_logger . setLevel ( logging . DEBUG ) self . logger = kusama_logger def info ( self , message ): self . logger . info ( message ) def error ( self , message ): self . logger . error ( message ) def debug ( self , message ): self . logger . debug ( message ) class PyTestLogger : \"\"\" Used for verifying logs output in tests \"\"\" def __init__ ( self ): self . LAST_MESSAGE = None def info ( self , message ): self . LAST_MESSAGE = message def error ( self , message ): self . LAST_MESSAGE = message def debug ( self , message ): self . LAST_MESSAGE = message Classes Logger class Logger ( ) View Source class Logger: def __init__ ( self ): kusama_logger = logging . getLogger ( \"kusama\" ) kusama_logger . setLevel ( logging . DEBUG ) self . logger = kusama_logger def info ( self , message ): self . logger . info ( message ) def error ( self , message ): self . logger . error ( message ) def debug ( self , message ): self . logger . debug ( message ) Methods debug def debug ( self , message ) View Source def debug ( self , message ): self . logger . debug ( message ) error def error ( self , message ) View Source def error ( self , message ): self . logger . error ( message ) info def info ( self , message ) View Source def info ( self , message ): self . logger . info ( message ) PyTestLogger class PyTestLogger ( ) Used for verifying logs output in tests View Source class PyTestLogger: \"\"\" Used for verifying logs output in tests \"\"\" def __init__ ( self ): self . LAST_MESSAGE = None def info ( self , message ): self . LAST_MESSAGE = message def error ( self , message ): self . LAST_MESSAGE = message def debug ( self , message ): self . LAST_MESSAGE = message Methods debug def debug ( self , message ) View Source def debug ( self , message ): self . LAST_MESSAGE = message error def error ( self , message ) View Source def error ( self , message ): self . LAST_MESSAGE = message info def info ( self , message ) View Source def info ( self , message ): self . LAST_MESSAGE = message","title":"Logging"},{"location":"reference/ksmutils/logging/#module-ksmutilslogging","text":"View Source import logging class Logger : def __init__ ( self ): kusama_logger = logging . getLogger ( \"kusama\" ) kusama_logger . setLevel ( logging . DEBUG ) self . logger = kusama_logger def info ( self , message ): self . logger . info ( message ) def error ( self , message ): self . logger . error ( message ) def debug ( self , message ): self . logger . debug ( message ) class PyTestLogger : \"\"\" Used for verifying logs output in tests \"\"\" def __init__ ( self ): self . LAST_MESSAGE = None def info ( self , message ): self . LAST_MESSAGE = message def error ( self , message ): self . LAST_MESSAGE = message def debug ( self , message ): self . LAST_MESSAGE = message","title":"Module ksmutils.logging"},{"location":"reference/ksmutils/logging/#classes","text":"","title":"Classes"},{"location":"reference/ksmutils/logging/#logger","text":"class Logger ( ) View Source class Logger: def __init__ ( self ): kusama_logger = logging . getLogger ( \"kusama\" ) kusama_logger . setLevel ( logging . DEBUG ) self . logger = kusama_logger def info ( self , message ): self . logger . info ( message ) def error ( self , message ): self . logger . error ( message ) def debug ( self , message ): self . logger . debug ( message )","title":"Logger"},{"location":"reference/ksmutils/logging/#methods","text":"","title":"Methods"},{"location":"reference/ksmutils/logging/#debug","text":"def debug ( self , message ) View Source def debug ( self , message ): self . logger . debug ( message )","title":"debug"},{"location":"reference/ksmutils/logging/#error","text":"def error ( self , message ) View Source def error ( self , message ): self . logger . error ( message )","title":"error"},{"location":"reference/ksmutils/logging/#info","text":"def info ( self , message ) View Source def info ( self , message ): self . logger . info ( message )","title":"info"},{"location":"reference/ksmutils/logging/#pytestlogger","text":"class PyTestLogger ( ) Used for verifying logs output in tests View Source class PyTestLogger: \"\"\" Used for verifying logs output in tests \"\"\" def __init__ ( self ): self . LAST_MESSAGE = None def info ( self , message ): self . LAST_MESSAGE = message def error ( self , message ): self . LAST_MESSAGE = message def debug ( self , message ): self . LAST_MESSAGE = message","title":"PyTestLogger"},{"location":"reference/ksmutils/logging/#methods_1","text":"","title":"Methods"},{"location":"reference/ksmutils/logging/#debug_1","text":"def debug ( self , message ) View Source def debug ( self , message ): self . LAST_MESSAGE = message","title":"debug"},{"location":"reference/ksmutils/logging/#error_1","text":"def error ( self , message ) View Source def error ( self , message ): self . LAST_MESSAGE = message","title":"error"},{"location":"reference/ksmutils/logging/#info_1","text":"def info ( self , message ) View Source def info ( self , message ): self . LAST_MESSAGE = message","title":"info"},{"location":"reference/ksmutils/network/","text":"Module ksmutils.network View Source import asyncio import json from logging import Logger import websockets _INSTANCE = None class Network : \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , * , logger : \"Logger\" = Logger , address : str = \"wss://kusama-rpc.polkadot.io/\" , ): global _INSTANCE assert _INSTANCE is None , \"Network is a singleton!\" _INSTANCE = self self . logger = logger () self . logger . info ( f \"Instantiating network connection to {address}\" ) self . address = address def node_rpc_call ( self , method , params , loop_limit = False , * , debug = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit , debug = debug ) ) async def _node_rpc_call ( self , method , params , loop_limit = False , * , debug = False ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . address ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) if debug : self . logger . debug ( \"Received from server\" , result ) ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ): looping = False event_number += 1 await ws_request ( payload ) return ws_results Classes Network class Network ( * , logger : 'Logger' = < class ' logging . Logger '>, address : str = 'wss://kusama-rpc.polkadot.io/' ) The Network class manages a connection to local/remote Kusama node View Source class Network: \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , *, logger: \"Logger\" = Logger , address: str = \"wss://kusama-rpc.polkadot.io/\" , ): global _INSTANCE assert _INSTANCE is None , \"Network is a singleton!\" _INSTANCE = self self . logger = logger () self . logger . info ( f \"Instantiating network connection to {address}\" ) self . address = address def node_rpc_call ( self , method , params , loop_limit = False , *, debug = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit , debug = debug ) ) async def _node_rpc_call ( self , method , params , loop_limit = False , *, debug = False ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . address ) as websocket: await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping: result = json . loads ( await websocket . recv ()) if debug: self . logger . debug ( \"Received from server\" , result ) ws_results . update ({ event_number: result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops: looping = False # End transactions when they are finalised if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ): looping = False event_number += 1 await ws_request ( payload ) return ws_results Methods node_rpc_call def node_rpc_call ( self , method , params , loop_limit = False , * , debug = False ) View Source def node_rpc_call ( self , method , params , loop_limit = False , * , debug = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit , debug = debug ) )","title":"Network"},{"location":"reference/ksmutils/network/#module-ksmutilsnetwork","text":"View Source import asyncio import json from logging import Logger import websockets _INSTANCE = None class Network : \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , * , logger : \"Logger\" = Logger , address : str = \"wss://kusama-rpc.polkadot.io/\" , ): global _INSTANCE assert _INSTANCE is None , \"Network is a singleton!\" _INSTANCE = self self . logger = logger () self . logger . info ( f \"Instantiating network connection to {address}\" ) self . address = address def node_rpc_call ( self , method , params , loop_limit = False , * , debug = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit , debug = debug ) ) async def _node_rpc_call ( self , method , params , loop_limit = False , * , debug = False ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . address ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) if debug : self . logger . debug ( \"Received from server\" , result ) ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ): looping = False event_number += 1 await ws_request ( payload ) return ws_results","title":"Module ksmutils.network"},{"location":"reference/ksmutils/network/#classes","text":"","title":"Classes"},{"location":"reference/ksmutils/network/#network","text":"class Network ( * , logger : 'Logger' = < class ' logging . Logger '>, address : str = 'wss://kusama-rpc.polkadot.io/' ) The Network class manages a connection to local/remote Kusama node View Source class Network: \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , *, logger: \"Logger\" = Logger , address: str = \"wss://kusama-rpc.polkadot.io/\" , ): global _INSTANCE assert _INSTANCE is None , \"Network is a singleton!\" _INSTANCE = self self . logger = logger () self . logger . info ( f \"Instantiating network connection to {address}\" ) self . address = address def node_rpc_call ( self , method , params , loop_limit = False , *, debug = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit , debug = debug ) ) async def _node_rpc_call ( self , method , params , loop_limit = False , *, debug = False ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . address ) as websocket: await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping: result = json . loads ( await websocket . recv ()) if debug: self . logger . debug ( \"Received from server\" , result ) ws_results . update ({ event_number: result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops: looping = False # End transactions when they are finalised if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ): looping = False event_number += 1 await ws_request ( payload ) return ws_results","title":"Network"},{"location":"reference/ksmutils/network/#methods","text":"","title":"Methods"},{"location":"reference/ksmutils/network/#node_rpc_call","text":"def node_rpc_call ( self , method , params , loop_limit = False , * , debug = False ) View Source def node_rpc_call ( self , method , params , loop_limit = False , * , debug = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit , debug = debug ) )","title":"node_rpc_call"},{"location":"reference/ksmutils/settings/","text":"Module ksmutils.settings","title":"Settings"},{"location":"reference/ksmutils/settings/#module-ksmutilssettings","text":"","title":"Module ksmutils.settings"}]}
