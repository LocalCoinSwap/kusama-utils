{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"substrate-utils Substrate utility library providing functionality for exchange management and multi-signature trading, originally built for LocalCoinSwap The focus of this library is on functionality needed to provide an exchange service, including: Account generation Balance checking Making transfers Creating N/M (2/3) escrow addresses Non-custodial trades Cancellation of trades Administration of trade disputes Verification of transactions Diagnostics for common problems Associated cryptography For complete examples please review the documentation. If there's any exchange functionality you need which we haven't provided, feel free to raise an issue in Github. Installation pip install substrate-utils Quick start from substrateutils import Kusama , Polkadot , Kulupu kusama = Kusama () polkadot = Polkadot () kulupu = Kulupu () Documentation https://localcoinswap.github.io/substrate-utils/ Local development Pre-requisites Python 3.8.1 (preferred) We suggest using pyenv to easily manage python versions. Some of the following commands use pyenv . Use pyenv-installer for easy installation. Then add pyenv-virtualenv plugin to it. Configure local development setup Install and activate python 3.8.1 in the root directory pyenv install 3.8.1 pyenv virtualenv 3.8.1 substrateutils pyenv local substrateutils Install project requirements pip install -r requirements.txt Install precommit hook pre-commit install You're all set to hack! Before making changes, let's ensure tests run successfully on local. Running Tests Run all tests with coverage coverage run -m pytest -v Show report in terminal coverage report -m Notes Trade storage calls for 2/3 trades cost: Polkadot - 40.3040 DOT Kusama - 6.71733331304 KSM","title":"Home"},{"location":"#substrate-utils","text":"Substrate utility library providing functionality for exchange management and multi-signature trading, originally built for LocalCoinSwap The focus of this library is on functionality needed to provide an exchange service, including: Account generation Balance checking Making transfers Creating N/M (2/3) escrow addresses Non-custodial trades Cancellation of trades Administration of trade disputes Verification of transactions Diagnostics for common problems Associated cryptography For complete examples please review the documentation. If there's any exchange functionality you need which we haven't provided, feel free to raise an issue in Github.","title":"substrate-utils"},{"location":"#installation","text":"pip install substrate-utils","title":"Installation"},{"location":"#quick-start","text":"from substrateutils import Kusama , Polkadot , Kulupu kusama = Kusama () polkadot = Polkadot () kulupu = Kulupu ()","title":"Quick start"},{"location":"#documentation","text":"https://localcoinswap.github.io/substrate-utils/","title":"Documentation"},{"location":"#local-development","text":"","title":"Local development"},{"location":"#pre-requisites","text":"Python 3.8.1 (preferred) We suggest using pyenv to easily manage python versions. Some of the following commands use pyenv . Use pyenv-installer for easy installation. Then add pyenv-virtualenv plugin to it.","title":"Pre-requisites"},{"location":"#configure-local-development-setup","text":"Install and activate python 3.8.1 in the root directory pyenv install 3.8.1 pyenv virtualenv 3.8.1 substrateutils pyenv local substrateutils Install project requirements pip install -r requirements.txt Install precommit hook pre-commit install You're all set to hack! Before making changes, let's ensure tests run successfully on local.","title":"Configure local development setup"},{"location":"#running-tests","text":"Run all tests with coverage coverage run -m pytest -v Show report in terminal coverage report -m","title":"Running Tests"},{"location":"#notes","text":"Trade storage calls for 2/3 trades cost: Polkadot - 40.3040 DOT Kusama - 6.71733331304 KSM","title":"Notes"},{"location":"docs/contributing/1.-local-development/","text":"Local Development Checklist before publishing the package Install pip install twine --dev Make sure to update REQUIRED and EXTRAS lists in setup.py based on what's required by the library and what's required only for development. To ease local development, we will continue to maintain requirements.txt which includes every package. Bump the version constant VERSION in setup.py Commit the version bump change in setup.py (It is okay to not push, but commit is required) Run setup test python setup.py test Publish package to PyPI python setup.py upload Enter PyPi credentials (note: you must be added to the project as a maintainer) Generating Documentation Generate on local for testing portray server Publishing the docs to https://localcoinswap.github.io/substrate-utils/ Please make sure the docs look as expected on local Checkout to docs-branch branch git checkout docs-branch Only difference between master and docs-branch is that the site/ is not gitignored in docs-branch Merge master into docs-branch git merge master Add the merge commit Run portray as_html --overwrite (Read portray docs to know more) That will generate html docs in site/ directory, it will overwrite the existing content Commit the changes and push to docs-branch git add site/ git commit git push origin docs-branch --force Run this nested git command to publish the changes in gh-pages branch (which serves the static html) git push origin `git subtree split --prefix site docs-branch`:gh-pages --force","title":"1. Local Development"},{"location":"docs/contributing/1.-local-development/#local-development","text":"","title":"Local Development"},{"location":"docs/contributing/1.-local-development/#checklist-before-publishing-the-package","text":"Install pip install twine --dev Make sure to update REQUIRED and EXTRAS lists in setup.py based on what's required by the library and what's required only for development. To ease local development, we will continue to maintain requirements.txt which includes every package. Bump the version constant VERSION in setup.py Commit the version bump change in setup.py (It is okay to not push, but commit is required) Run setup test python setup.py test Publish package to PyPI python setup.py upload Enter PyPi credentials (note: you must be added to the project as a maintainer)","title":"Checklist before publishing the package"},{"location":"docs/contributing/1.-local-development/#generating-documentation","text":"Generate on local for testing portray server Publishing the docs to https://localcoinswap.github.io/substrate-utils/ Please make sure the docs look as expected on local Checkout to docs-branch branch git checkout docs-branch Only difference between master and docs-branch is that the site/ is not gitignored in docs-branch Merge master into docs-branch git merge master Add the merge commit Run portray as_html --overwrite (Read portray docs to know more) That will generate html docs in site/ directory, it will overwrite the existing content Commit the changes and push to docs-branch git add site/ git commit git push origin docs-branch --force Run this nested git command to publish the changes in gh-pages branch (which serves the static html) git push origin `git subtree split --prefix site docs-branch`:gh-pages --force","title":"Generating Documentation"},{"location":"docs/examples/basic-usage/","text":"Basic setup of the module Instantiating without configuration from substrateutils import Kusama , Polkadot kusama = Kusama () polkadot = Polkadot () Loading configuration after instantiation from substrateutils import Kusama , Polkadot kusama , polkadot = Kusama (), Polkadot () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' kusama . setup_arbitrator ( arbitrator_key ) polkadot . setup_arbitrator ( arbitrator_key ) Instantiating with arbitrator and websocket configuration from substrateutils import Kusama , Polkadot kusama , polkadot = Kusama (), Polkadot () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' ksm_provider = 'wss://kusama-rpc.polkadot.io/' dot_provider = 'wss://rpc.polkadot.io/' kusama = Kusama ( arbitrator_key = arbitrator_key , node_url = ksm_provider ) polkadot = Kusama ( arbitrator_key = arbitrator_key , node_url = dot_provider ) Connecting to the blockchain and getting runtime chain . connect () chain . runtime_info () Preparing and sending a generic transfer import sr25519 from substrateutils import Polkadot as Provider from substrateutils.helper import hex_to_bytes from scalecodec.utils.ss58 import ss58_encode chain = Provider () chain . connect () sender_seed_hex = \"<SEED OF SENDER>\" to_address = \"<TO ADDRESS>\" value = 10000000000 # 1 DOT # Prepare key keypair = sr25519 . pair_from_seed ( hex_to_bytes ( sender_seed_hex )) sender_address = ss58_encode ( keypair [ 0 ], 0 ) # Get transaction payload to sign and nonce payload = chain . transfer_payload ( sender_address , to_address , value ) nonce = chain . get_nonce ( sender_address ) # Sign payload signed_payload = sr25519 . sign ( keypair , hex_to_bytes ( payload )) . hex () # Broadcast payload success , response = chain . publish ( 'transfer' , [ sender_address , signed_payload , nonce , to_address , value ] ) assert success print ( response )","title":"Basic Usage"},{"location":"docs/examples/basic-usage/#basic-setup-of-the-module","text":"","title":"Basic setup of the module"},{"location":"docs/examples/basic-usage/#instantiating-without-configuration","text":"from substrateutils import Kusama , Polkadot kusama = Kusama () polkadot = Polkadot ()","title":"Instantiating without configuration"},{"location":"docs/examples/basic-usage/#loading-configuration-after-instantiation","text":"from substrateutils import Kusama , Polkadot kusama , polkadot = Kusama (), Polkadot () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' kusama . setup_arbitrator ( arbitrator_key ) polkadot . setup_arbitrator ( arbitrator_key )","title":"Loading configuration after instantiation"},{"location":"docs/examples/basic-usage/#instantiating-with-arbitrator-and-websocket-configuration","text":"from substrateutils import Kusama , Polkadot kusama , polkadot = Kusama (), Polkadot () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' ksm_provider = 'wss://kusama-rpc.polkadot.io/' dot_provider = 'wss://rpc.polkadot.io/' kusama = Kusama ( arbitrator_key = arbitrator_key , node_url = ksm_provider ) polkadot = Kusama ( arbitrator_key = arbitrator_key , node_url = dot_provider )","title":"Instantiating with arbitrator and websocket configuration"},{"location":"docs/examples/basic-usage/#connecting-to-the-blockchain-and-getting-runtime","text":"chain . connect () chain . runtime_info ()","title":"Connecting to the blockchain and getting runtime"},{"location":"docs/examples/basic-usage/#preparing-and-sending-a-generic-transfer","text":"import sr25519 from substrateutils import Polkadot as Provider from substrateutils.helper import hex_to_bytes from scalecodec.utils.ss58 import ss58_encode chain = Provider () chain . connect () sender_seed_hex = \"<SEED OF SENDER>\" to_address = \"<TO ADDRESS>\" value = 10000000000 # 1 DOT # Prepare key keypair = sr25519 . pair_from_seed ( hex_to_bytes ( sender_seed_hex )) sender_address = ss58_encode ( keypair [ 0 ], 0 ) # Get transaction payload to sign and nonce payload = chain . transfer_payload ( sender_address , to_address , value ) nonce = chain . get_nonce ( sender_address ) # Sign payload signed_payload = sr25519 . sign ( keypair , hex_to_bytes ( payload )) . hex () # Broadcast payload success , response = chain . publish ( 'transfer' , [ sender_address , signed_payload , nonce , to_address , value ] ) assert success print ( response )","title":"Preparing and sending a generic transfer"},{"location":"docs/examples/non-custodial-trades/","text":"Non-custodial trades using the utility module First, setup the module and connect to the blockchain using the instructions in the basic-usage section. You can now use the library to go through each step of the trading process. Please be aware of the distinction between user transactions and arbitrator transactions. User transactions need to be broadcast using the publish method, as there is construction required. Arbitrator transactions can be immediately broadcast using broadcast since they are already constructed. The following code snippet instantiates everything needed to follow these examples. You will need to provide you own environment variables in a local .env file: import os from dotenv import load_dotenv from substrateutils import Polkadot as Provider load_dotenv () chain = Provider () arbitrator_key = os . getenv ( \"ARBITRATOR_SEED\" ) chain . setup_arbitrator ( arbitrator_key ) chain . connect () Generate an escrow address buyer_address = os . getenv ( \"BUYER_ADDRESS\" ) seller_address = os . getenv ( \"SELLER_ADDRESS\" ) escrow_address = chain . get_escrow_address ( buyer_address , seller_address ) Generate the signature payloads to fund the escrow and send the fee # Value of the trade in Plancks trade_value = 10000000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) fee_value = 100000000 escrow_payload , fee_payload , nonce = chain . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value ) Sign the payloads import sr25519 from substrateutils.helper import sign_payload seller_key = os . getenv ( \"SELLER_SEED\" ) keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) escrow_signature = sign_payload ( keypair , escrow_payload ) fee_signature = sign_payload ( keypair , fee_payload ) Construct and broadcast the transactions success , response = chain . publish ( 'transfer' , [ seller_address , escrow_signature , nonce , escrow_address , trade_value ] ) assert success success , response = chain . publish ( 'fee_transfer' , [ seller_address , fee_signature , nonce + 1 , fee_value ] ) assert success Happy case: regular release # Arbitrater makes storage as_multi to buyer transaction = chain . as_multi_storage ( buyer_address , # To address seller_address , # Other signatory trade_value , ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Seller makes as_multi to release as_multi_payload , nonce = chain . as_multi_payload ( seller_address , # from buyer_address , # to trade_value , [ buyer_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store ) as_multi_signature = sign_payload ( seller_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ seller_address , # from as_multi_signature , # sig nonce , # seller nonce buyer_address , # to trade_value , timepoint , # timepoint [ buyer_address , chain . arbitrator_address ], # other sigs 0 , ] ) Neutral case: trade cancellation, return funds to seller # Arbitrater makes storage as_multi back to seller transaction = chain . as_multi_storage ( seller_address , # To address buyer_address , # Other signatory trade_value ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Return the fee transaction = chain . fee_return_transaction ( seller_address , trade_value , fee_value , ) success , response = chain . broadcast ( 'transfer' , transaction ) # Seller as_multi to return funds as_multi_payload , nonce = chain . as_multi_payload ( seller_address , # from seller_address , # to trade_value , [ buyer_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store ) as_multi_signature = sign_payload ( seller_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ seller_address , # from as_multi_signature , # sig nonce , # seller nonce seller_address , # to trade_value , timepoint , # timepoint [ buyer_address , chain . arbitrator_address ], # other sigs 0 , ] ) Sad case: dispute (buyer wins) # Arbitrater makes storage as_multi to buyer transaction = chain . as_multi_storage ( buyer_address , # To address seller_address , # Other signatory trade_value ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Arbitrator makes welfare payment to buyer transaction = chain . welfare_transaction ( buyer_address , ) success , response = chain . broadcast ( 'transfer' , transaction ) # Buyer as_multi to receive funds as_multi_payload , nonce = chain . as_multi_payload ( buyer_address , # from buyer_address , # to trade_value , [ seller_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store, ) as_multi_signature = sign_payload ( buyer_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ buyer_address , # from as_multi_signature , # sig nonce , # seller nonce buyer_address , # to trade_value , timepoint , # timepoint [ seller_address , chain . arbitrator_address ], # other sigs 0 , ] ) Sad case: dispute (seller wins) In this situation the flow is exactly the same as the cancellation flow # Arbitrater makes storage as_multi back to seller transaction = chain . as_multi_storage ( seller_address , # To address buyer_address , # Other signatory trade_value ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Return the fee transaction = chain . fee_return_transaction ( seller_address , trade_value , fee_value , ) success , response = chain . broadcast ( 'transfer' , transaction ) # Seller as_multi to return funds as_multi_payload , nonce = chain . as_multi_payload ( seller_address , # from seller_address , # to trade_value , [ buyer_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store ) as_multi_signature = sign_payload ( seller_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ seller_address , # from as_multi_signature , # sig nonce , # seller nonce seller_address , # to trade_value , timepoint , # timepoint [ buyer_address , chain . arbitrator_address ], # other sigs 0 , ] ) End-to-end trade flow in happy case This is a purposely verbose, line by line execution for an entire trade. This is useful for manual testing. import os import sr25519 from dotenv import load_dotenv from scalecodec.utils.ss58 import ss58_encode from substrateutils.helper import sign_payload from substrateutils import Polkadot as Provider load_dotenv () chain = Provider () arbitrator_key = os . getenv ( \"ARBITRATOR_SEED\" ) chain . setup_arbitrator ( arbitrator_key ) chain . connect () # Get seller and buyer addresses seller_key = os . getenv ( \"SELLER_SEED\" ) buyer_key = os . getenv ( \"BUYER_SEED\" ) seller_keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) buyer_keypair = sr25519 . pair_from_seed ( bytes . fromhex ( buyer_key )) seller_address = ss58_encode ( seller_keypair [ 0 ], 0 ) buyer_address = ss58_encode ( buyer_keypair [ 0 ], 0 ) escrow_address = chain . get_escrow_address ( buyer_address , seller_address ) # Value of the trade in Plancks trade_value = 10000000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) fee_value = 100000000 escrow_payload , fee_payload , nonce = chain . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value ) escrow_signature = sign_payload ( seller_keypair , escrow_payload ) fee_signature = sign_payload ( seller_keypair , fee_payload ) success , response = chain . publish ( 'transfer' , [ seller_address , escrow_signature , nonce , escrow_address , trade_value ] ) success , response = chain . publish ( 'fee_transfer' , [ seller_address , fee_signature , nonce + 1 , fee_value ] ) transaction = chain . as_multi_storage ( buyer_address , # To address seller_address , # Other signatory trade_value , ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Seller makes as_multi to release as_multi_payload , nonce = chain . as_multi_payload ( seller_address , # from buyer_address , # to trade_value , [ buyer_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store, ) as_multi_signature = sign_payload ( seller_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ seller_address , # from as_multi_signature , # sig nonce , # seller nonce buyer_address , # to trade_value , timepoint , # timepoint [ buyer_address , chain . arbitrator_address ], # other sigs 0 , # reverts to chain default ] )","title":"Non Custodial Trades"},{"location":"docs/examples/non-custodial-trades/#non-custodial-trades-using-the-utility-module","text":"First, setup the module and connect to the blockchain using the instructions in the basic-usage section. You can now use the library to go through each step of the trading process. Please be aware of the distinction between user transactions and arbitrator transactions. User transactions need to be broadcast using the publish method, as there is construction required. Arbitrator transactions can be immediately broadcast using broadcast since they are already constructed. The following code snippet instantiates everything needed to follow these examples. You will need to provide you own environment variables in a local .env file: import os from dotenv import load_dotenv from substrateutils import Polkadot as Provider load_dotenv () chain = Provider () arbitrator_key = os . getenv ( \"ARBITRATOR_SEED\" ) chain . setup_arbitrator ( arbitrator_key ) chain . connect ()","title":"Non-custodial trades using the utility module"},{"location":"docs/examples/non-custodial-trades/#generate-an-escrow-address","text":"buyer_address = os . getenv ( \"BUYER_ADDRESS\" ) seller_address = os . getenv ( \"SELLER_ADDRESS\" ) escrow_address = chain . get_escrow_address ( buyer_address , seller_address )","title":"Generate an escrow address"},{"location":"docs/examples/non-custodial-trades/#generate-the-signature-payloads-to-fund-the-escrow-and-send-the-fee","text":"# Value of the trade in Plancks trade_value = 10000000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) fee_value = 100000000 escrow_payload , fee_payload , nonce = chain . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value )","title":"Generate the signature payloads to fund the escrow and send the fee"},{"location":"docs/examples/non-custodial-trades/#sign-the-payloads","text":"import sr25519 from substrateutils.helper import sign_payload seller_key = os . getenv ( \"SELLER_SEED\" ) keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) escrow_signature = sign_payload ( keypair , escrow_payload ) fee_signature = sign_payload ( keypair , fee_payload )","title":"Sign the payloads"},{"location":"docs/examples/non-custodial-trades/#construct-and-broadcast-the-transactions","text":"success , response = chain . publish ( 'transfer' , [ seller_address , escrow_signature , nonce , escrow_address , trade_value ] ) assert success success , response = chain . publish ( 'fee_transfer' , [ seller_address , fee_signature , nonce + 1 , fee_value ] ) assert success","title":"Construct and broadcast the transactions"},{"location":"docs/examples/non-custodial-trades/#happy-case-regular-release","text":"# Arbitrater makes storage as_multi to buyer transaction = chain . as_multi_storage ( buyer_address , # To address seller_address , # Other signatory trade_value , ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Seller makes as_multi to release as_multi_payload , nonce = chain . as_multi_payload ( seller_address , # from buyer_address , # to trade_value , [ buyer_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store ) as_multi_signature = sign_payload ( seller_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ seller_address , # from as_multi_signature , # sig nonce , # seller nonce buyer_address , # to trade_value , timepoint , # timepoint [ buyer_address , chain . arbitrator_address ], # other sigs 0 , ] )","title":"Happy case: regular release"},{"location":"docs/examples/non-custodial-trades/#neutral-case-trade-cancellation-return-funds-to-seller","text":"# Arbitrater makes storage as_multi back to seller transaction = chain . as_multi_storage ( seller_address , # To address buyer_address , # Other signatory trade_value ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Return the fee transaction = chain . fee_return_transaction ( seller_address , trade_value , fee_value , ) success , response = chain . broadcast ( 'transfer' , transaction ) # Seller as_multi to return funds as_multi_payload , nonce = chain . as_multi_payload ( seller_address , # from seller_address , # to trade_value , [ buyer_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store ) as_multi_signature = sign_payload ( seller_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ seller_address , # from as_multi_signature , # sig nonce , # seller nonce seller_address , # to trade_value , timepoint , # timepoint [ buyer_address , chain . arbitrator_address ], # other sigs 0 , ] )","title":"Neutral case: trade cancellation, return funds to seller"},{"location":"docs/examples/non-custodial-trades/#sad-case-dispute-buyer-wins","text":"# Arbitrater makes storage as_multi to buyer transaction = chain . as_multi_storage ( buyer_address , # To address seller_address , # Other signatory trade_value ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Arbitrator makes welfare payment to buyer transaction = chain . welfare_transaction ( buyer_address , ) success , response = chain . broadcast ( 'transfer' , transaction ) # Buyer as_multi to receive funds as_multi_payload , nonce = chain . as_multi_payload ( buyer_address , # from buyer_address , # to trade_value , [ seller_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store, ) as_multi_signature = sign_payload ( buyer_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ buyer_address , # from as_multi_signature , # sig nonce , # seller nonce buyer_address , # to trade_value , timepoint , # timepoint [ seller_address , chain . arbitrator_address ], # other sigs 0 , ] )","title":"Sad case: dispute (buyer wins)"},{"location":"docs/examples/non-custodial-trades/#sad-case-dispute-seller-wins","text":"In this situation the flow is exactly the same as the cancellation flow # Arbitrater makes storage as_multi back to seller transaction = chain . as_multi_storage ( seller_address , # To address buyer_address , # Other signatory trade_value ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Return the fee transaction = chain . fee_return_transaction ( seller_address , trade_value , fee_value , ) success , response = chain . broadcast ( 'transfer' , transaction ) # Seller as_multi to return funds as_multi_payload , nonce = chain . as_multi_payload ( seller_address , # from seller_address , # to trade_value , [ buyer_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store ) as_multi_signature = sign_payload ( seller_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ seller_address , # from as_multi_signature , # sig nonce , # seller nonce seller_address , # to trade_value , timepoint , # timepoint [ buyer_address , chain . arbitrator_address ], # other sigs 0 , ] )","title":"Sad case: dispute (seller wins)"},{"location":"docs/examples/non-custodial-trades/#end-to-end-trade-flow-in-happy-case","text":"This is a purposely verbose, line by line execution for an entire trade. This is useful for manual testing. import os import sr25519 from dotenv import load_dotenv from scalecodec.utils.ss58 import ss58_encode from substrateutils.helper import sign_payload from substrateutils import Polkadot as Provider load_dotenv () chain = Provider () arbitrator_key = os . getenv ( \"ARBITRATOR_SEED\" ) chain . setup_arbitrator ( arbitrator_key ) chain . connect () # Get seller and buyer addresses seller_key = os . getenv ( \"SELLER_SEED\" ) buyer_key = os . getenv ( \"BUYER_SEED\" ) seller_keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) buyer_keypair = sr25519 . pair_from_seed ( bytes . fromhex ( buyer_key )) seller_address = ss58_encode ( seller_keypair [ 0 ], 0 ) buyer_address = ss58_encode ( buyer_keypair [ 0 ], 0 ) escrow_address = chain . get_escrow_address ( buyer_address , seller_address ) # Value of the trade in Plancks trade_value = 10000000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) fee_value = 100000000 escrow_payload , fee_payload , nonce = chain . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value ) escrow_signature = sign_payload ( seller_keypair , escrow_payload ) fee_signature = sign_payload ( seller_keypair , fee_payload ) success , response = chain . publish ( 'transfer' , [ seller_address , escrow_signature , nonce , escrow_address , trade_value ] ) success , response = chain . publish ( 'fee_transfer' , [ seller_address , fee_signature , nonce + 1 , fee_value ] ) transaction = chain . as_multi_storage ( buyer_address , # To address seller_address , # Other signatory trade_value , ) success , response = chain . broadcast ( 'as_multi' , transaction ) timepoint = response [ 'timepoint' ] # Seller makes as_multi to release as_multi_payload , nonce = chain . as_multi_payload ( seller_address , # from buyer_address , # to trade_value , [ buyer_address , chain . arbitrator_address ], timepoint , # timepoint from storage False , # don't store, ) as_multi_signature = sign_payload ( seller_keypair , as_multi_payload ) success , response = chain . publish ( 'as_multi' , [ seller_address , # from as_multi_signature , # sig nonce , # seller nonce buyer_address , # to trade_value , timepoint , # timepoint [ buyer_address , chain . arbitrator_address ], # other sigs 0 , # reverts to chain default ] )","title":"End-to-end trade flow in happy case"},{"location":"docs/examples/trade-class-usage/","text":"Using the trade class The trade class is intended to allow developers to examine the mechanics of a P2P trade in the most straightforward manner possible. You can run through the process of a trade, and then examine the individual functions to see what happens. The process of a non-custodial trade is explained in our Substrate reference document: https://github.com/LocalCoinSwap/substrate-multisig-reference/ The trade class is not appropriate for production usage, because it requires all trading parties to expose their private keys to the class. Instead, you can use the mechanics of the process for your own implementations. If you need an API service which abstracts the useful mechanics of the process into REST-API calls, you can use: https://github.com/LocalCoinSwap/substrate-api Instantiation You'll first need some private keys, mnemonics or address hexs. The default cryptocurrency in the trade class is Polkadot, but you can pass it any kind of crypto core. import os from dotenv import load_dotenv load_dotenv () from substrateutils import TradeManager from substrateutils import User Buyer = User ( hex = os . getenv ( \"BUYER_SEED\" )) Seller = User ( hex = os . getenv ( \"SELLER_SEED\" )) Arbitrator = User ( hex = os . getenv ( \"ARBITRATOR_SEED\" )) Trade = TradeManager ( Buyer , Seller , Arbitrator , 25000000000 , # Trade value fee_value = 200000000 , ) Demonstrating the trading flow The trading flow is deliberately simple so you can examine the underlying code yourself. In fact you only need a single command for each step. Funding escrow: Trade . fund_escrow () Releasing escrow: Trade . release () Cancel a trade: Trade . cancel () Disputing in favour of a buyer: Trade . dispute ( winner = \"BUYER\" ) Disputing in favour of a seller: Trade . dispute ( winner = \"SELLER\" ) Yep, it's that easy :)","title":"Trade Class Usage"},{"location":"docs/examples/trade-class-usage/#using-the-trade-class","text":"The trade class is intended to allow developers to examine the mechanics of a P2P trade in the most straightforward manner possible. You can run through the process of a trade, and then examine the individual functions to see what happens. The process of a non-custodial trade is explained in our Substrate reference document: https://github.com/LocalCoinSwap/substrate-multisig-reference/ The trade class is not appropriate for production usage, because it requires all trading parties to expose their private keys to the class. Instead, you can use the mechanics of the process for your own implementations. If you need an API service which abstracts the useful mechanics of the process into REST-API calls, you can use: https://github.com/LocalCoinSwap/substrate-api","title":"Using the trade class"},{"location":"docs/examples/trade-class-usage/#instantiation","text":"You'll first need some private keys, mnemonics or address hexs. The default cryptocurrency in the trade class is Polkadot, but you can pass it any kind of crypto core. import os from dotenv import load_dotenv load_dotenv () from substrateutils import TradeManager from substrateutils import User Buyer = User ( hex = os . getenv ( \"BUYER_SEED\" )) Seller = User ( hex = os . getenv ( \"SELLER_SEED\" )) Arbitrator = User ( hex = os . getenv ( \"ARBITRATOR_SEED\" )) Trade = TradeManager ( Buyer , Seller , Arbitrator , 25000000000 , # Trade value fee_value = 200000000 , )","title":"Instantiation"},{"location":"docs/examples/trade-class-usage/#demonstrating-the-trading-flow","text":"The trading flow is deliberately simple so you can examine the underlying code yourself. In fact you only need a single command for each step. Funding escrow: Trade . fund_escrow () Releasing escrow: Trade . release () Cancel a trade: Trade . cancel () Disputing in favour of a buyer: Trade . dispute ( winner = \"BUYER\" ) Disputing in favour of a seller: Trade . dispute ( winner = \"SELLER\" ) Yep, it's that easy :)","title":"Demonstrating the trading flow"},{"location":"reference/substrateutils/","text":"Module substrateutils View Source from .cores import Kulupu from .cores import Kusama from .cores import Polkadot from .cores import update_registry from .network import Network from .trades import TradeManager from .trades import User __all__ = [ Kusama , Polkadot , Kulupu , Network , update_registry , TradeManager , User ] Sub-modules substrateutils.cores substrateutils.helper substrateutils.network substrateutils.nonce substrateutils.settings substrateutils.trades","title":"Index"},{"location":"reference/substrateutils/#module-substrateutils","text":"View Source from .cores import Kulupu from .cores import Kusama from .cores import Polkadot from .cores import update_registry from .network import Network from .trades import TradeManager from .trades import User __all__ = [ Kusama , Polkadot , Kulupu , Network , update_registry , TradeManager , User ]","title":"Module substrateutils"},{"location":"reference/substrateutils/#sub-modules","text":"substrateutils.cores substrateutils.helper substrateutils.network substrateutils.nonce substrateutils.settings substrateutils.trades","title":"Sub-modules"},{"location":"reference/substrateutils/cores/","text":"Module substrateutils.cores View Source import logging from hashlib import blake2b import sr25519 from scalecodec import ScaleBytes from scalecodec.base import RuntimeConfigurationObject from scalecodec.base import ScaleDecoder from scalecodec.block import ExtrinsicsDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.type_registry import load_type_registry_preset from scalecodec.updater import update_type_registries from scalecodec.utils.ss58 import ss58_decode from scalecodec.utils.ss58 import ss58_encode from . import helper from .network import Network from .nonce import NonceManager logger = logging . getLogger ( __name__ ) class SubstrateBase ( NonceManager ): def __init__ ( self , * , node_url : str = None , arbitrator_key : str = None , ): self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type ) def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ])[ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata ) def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] def _get_address_info ( self , address : str ) -> dict : \"\"\" Returns information associated with provided address \"\"\" # Storage key: # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , self . address_type ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ])[ \"result\" ] if not result : return { \"nonce\" : 0 , \"refcount\" : 0 , \"data\" : { \"free\" : 0 , \"reserved\" : 0 , \"miscFrozen\" : 0 , \"feeFrozen\" : 0 }, } return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ])[ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ], 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ]): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key: # xxHash128(System) + xxHash128(Events) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () def _get_extrinsic_index ( self , block_extrinsics : list , extrinsic_hash : str ) -> int : \"\"\" Returns the index of a provided extrinsic \"\"\" for idx , extrinsics in enumerate ( block_extrinsics ): ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return - 1 def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ) . digest () . hex () ) def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ) . get ( \"header\" ) . get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ) . get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {}) . get ( \"result\" , {}) . get ( \"finalized\" ) ) def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ], watch = True ) if \"error\" in str ( node_response ): return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ]) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ]) if not getkeys_response . get ( \"result\" , False ): response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ]: storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ])[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item [ 178 :]] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction class Kusama ( SubstrateBase ): def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ): self . chain = \"kusama\" self . address_type = 2 self . max_weight = 190949000 self . welfare_value = 4000000000 # 0.004 KSM super ( Kusama , self ) . __init__ ( node_url = node_url , arbitrator_key = arbitrator_key ) class Polkadot ( SubstrateBase ): def __init__ ( self , * , node_url : str = \"wss://rpc.polkadot.io/\" , arbitrator_key : str = None , ): self . chain = \"polkadot\" self . address_type = 0 self . max_weight = 648378000 self . welfare_value = 400000000 # 0.04 DOT super ( Polkadot , self ) . __init__ ( node_url = node_url , arbitrator_key = arbitrator_key ) class Kulupu ( SubstrateBase ): def __init__ ( self , * , node_url : str = \"wss://rpc.kulupu.corepaper.org/ws\" , arbitrator_key : str = None , ): self . chain = \"kulupu\" self . address_type = 16 super ( Kulupu , self ) . __init__ ( node_url = node_url , arbitrator_key = arbitrator_key ) def update_registry (): update_type_registries () Variables logger Functions update_registry def update_registry ( ) View Source def update_registry () : update_type_registries () Classes Kulupu class Kulupu ( * , node_url : str = 'wss://rpc.kulupu.corepaper.org/ws' , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class Kulupu ( SubstrateBase ): def __init__ ( self , *, node_url: str = \"wss://rpc.kulupu.corepaper.org/ws\" , arbitrator_key: str = None , ): self . chain = \"kulupu\" self . address_type = 16 super ( Kulupu , self ). __init__ ( node_url = node_url , arbitrator_key = arbitrator_key ) Ancestors (in MRO) substrateutils.cores.SubstrateBase substrateutils.nonce.NonceManager abc.ABC Methods arbitrator_nonce def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce as_multi_payload def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce as_multi_storage def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 ) View Source def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction broadcast def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) if \"error\" in str ( node_response ) : return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response connect def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash () diagnose def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response dump_metadata def dump_metadata ( self , filename : str = 'metadata.txt' ) -> None Dump the raw metadata to a file in root directory View Source def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata ) escrow_payloads def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce fee_return_transaction def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int ) -> str View Source def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction get_balance def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] get_block def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response get_block_hash def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node response View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) ) get_escrow_address def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address get_events def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () get_extrinsic_events def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events get_extrinsic_hash def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () ) get_extrinsic_timepoint def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) get_genesis_hash def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] get_mempool_nonce def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce get_metadata def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata get_nonce def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] get_pending_extrinsics def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics is_transaction_success def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful load_type_registry def load_type_registry ( self ) View Source def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config publish def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) runtime_info def runtime_info ( self ) -> int Check the current runtime and load the correct spec vesion and transaction version View Source def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] setup_arbitrator def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type ) transfer_payload def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_transaction def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ) -> str View Source def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction Kusama class Kusama ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class Kusama ( SubstrateBase ): def __init__ ( self , *, node_url: str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key: str = None , ): self . chain = \"kusama\" self . address_type = 2 self . max_weight = 190949000 self . welfare_value = 4000000000 # 0.004 KSM super ( Kusama , self ). __init__ ( node_url = node_url , arbitrator_key = arbitrator_key ) Ancestors (in MRO) substrateutils.cores.SubstrateBase substrateutils.nonce.NonceManager abc.ABC Methods arbitrator_nonce def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce as_multi_payload def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce as_multi_storage def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 ) View Source def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction broadcast def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) if \"error\" in str ( node_response ) : return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response connect def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash () diagnose def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response dump_metadata def dump_metadata ( self , filename : str = 'metadata.txt' ) -> None Dump the raw metadata to a file in root directory View Source def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata ) escrow_payloads def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce fee_return_transaction def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int ) -> str View Source def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction get_balance def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] get_block def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response get_block_hash def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node response View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) ) get_escrow_address def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address get_events def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () get_extrinsic_events def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events get_extrinsic_hash def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () ) get_extrinsic_timepoint def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) get_genesis_hash def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] get_mempool_nonce def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce get_metadata def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata get_nonce def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] get_pending_extrinsics def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics is_transaction_success def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful load_type_registry def load_type_registry ( self ) View Source def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config publish def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) runtime_info def runtime_info ( self ) -> int Check the current runtime and load the correct spec vesion and transaction version View Source def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] setup_arbitrator def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type ) transfer_payload def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_transaction def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ) -> str View Source def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction Polkadot class Polkadot ( * , node_url : str = 'wss://rpc.polkadot.io/' , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class Polkadot ( SubstrateBase ): def __init__ ( self , *, node_url: str = \"wss://rpc.polkadot.io/\" , arbitrator_key: str = None , ): self . chain = \"polkadot\" self . address_type = 0 self . max_weight = 648378000 self . welfare_value = 400000000 # 0.04 DOT super ( Polkadot , self ). __init__ ( node_url = node_url , arbitrator_key = arbitrator_key ) Ancestors (in MRO) substrateutils.cores.SubstrateBase substrateutils.nonce.NonceManager abc.ABC Methods arbitrator_nonce def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce as_multi_payload def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce as_multi_storage def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 ) View Source def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction broadcast def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) if \"error\" in str ( node_response ) : return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response connect def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash () diagnose def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response dump_metadata def dump_metadata ( self , filename : str = 'metadata.txt' ) -> None Dump the raw metadata to a file in root directory View Source def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata ) escrow_payloads def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce fee_return_transaction def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int ) -> str View Source def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction get_balance def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] get_block def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response get_block_hash def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node response View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) ) get_escrow_address def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address get_events def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () get_extrinsic_events def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events get_extrinsic_hash def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () ) get_extrinsic_timepoint def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) get_genesis_hash def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] get_mempool_nonce def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce get_metadata def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata get_nonce def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] get_pending_extrinsics def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics is_transaction_success def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful load_type_registry def load_type_registry ( self ) View Source def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config publish def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) runtime_info def runtime_info ( self ) -> int Check the current runtime and load the correct spec vesion and transaction version View Source def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] setup_arbitrator def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type ) transfer_payload def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_transaction def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ) -> str View Source def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction SubstrateBase class SubstrateBase ( * , node_url : str = None , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class SubstrateBase ( NonceManager ): def __init__ ( self , * , node_url : str = None , arbitrator_key : str = None , ): self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type ) def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ])[ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata ) def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] def _get_address_info ( self , address : str ) -> dict : \"\"\" Returns information associated with provided address \"\"\" # Storage key: # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , self . address_type ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ])[ \"result\" ] if not result : return { \"nonce\" : 0 , \"refcount\" : 0 , \"data\" : { \"free\" : 0 , \"reserved\" : 0 , \"miscFrozen\" : 0 , \"feeFrozen\" : 0 }, } return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ])[ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ], 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ]): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key: # xxHash128(System) + xxHash128(Events) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () def _get_extrinsic_index ( self , block_extrinsics : list , extrinsic_hash : str ) -> int : \"\"\" Returns the index of a provided extrinsic \"\"\" for idx , extrinsics in enumerate ( block_extrinsics ): ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return - 1 def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ) . digest () . hex () ) def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ) . get ( \"header\" ) . get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ) . get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {}) . get ( \"result\" , {}) . get ( \"finalized\" ) ) def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ], watch = True ) if \"error\" in str ( node_response ): return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ]) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ]) if not getkeys_response . get ( \"result\" , False ): response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ]: storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ])[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item [ 178 :]] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction Ancestors (in MRO) substrateutils.nonce.NonceManager abc.ABC Descendants substrateutils.cores.Kusama substrateutils.cores.Polkadot substrateutils.cores.Kulupu Methods arbitrator_nonce def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce as_multi_payload def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce as_multi_storage def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 ) View Source def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction broadcast def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) if \"error\" in str ( node_response ) : return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response connect def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash () diagnose def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response dump_metadata def dump_metadata ( self , filename : str = 'metadata.txt' ) -> None Dump the raw metadata to a file in root directory View Source def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata ) escrow_payloads def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce fee_return_transaction def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int ) -> str View Source def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction get_balance def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] get_block def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response get_block_hash def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node response View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) ) get_escrow_address def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address get_events def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () get_extrinsic_events def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events get_extrinsic_hash def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () ) get_extrinsic_timepoint def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) get_genesis_hash def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] get_mempool_nonce def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce get_metadata def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata get_nonce def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] get_pending_extrinsics def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics is_transaction_success def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful load_type_registry def load_type_registry ( self ) View Source def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config publish def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) runtime_info def runtime_info ( self ) -> int Check the current runtime and load the correct spec vesion and transaction version View Source def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] setup_arbitrator def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type ) transfer_payload def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_transaction def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ) -> str View Source def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction","title":"Cores"},{"location":"reference/substrateutils/cores/#module-substrateutilscores","text":"View Source import logging from hashlib import blake2b import sr25519 from scalecodec import ScaleBytes from scalecodec.base import RuntimeConfigurationObject from scalecodec.base import ScaleDecoder from scalecodec.block import ExtrinsicsDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.type_registry import load_type_registry_preset from scalecodec.updater import update_type_registries from scalecodec.utils.ss58 import ss58_decode from scalecodec.utils.ss58 import ss58_encode from . import helper from .network import Network from .nonce import NonceManager logger = logging . getLogger ( __name__ ) class SubstrateBase ( NonceManager ): def __init__ ( self , * , node_url : str = None , arbitrator_key : str = None , ): self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type ) def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ])[ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata ) def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] def _get_address_info ( self , address : str ) -> dict : \"\"\" Returns information associated with provided address \"\"\" # Storage key: # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , self . address_type ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ])[ \"result\" ] if not result : return { \"nonce\" : 0 , \"refcount\" : 0 , \"data\" : { \"free\" : 0 , \"reserved\" : 0 , \"miscFrozen\" : 0 , \"feeFrozen\" : 0 }, } return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ])[ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ], 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ]): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key: # xxHash128(System) + xxHash128(Events) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () def _get_extrinsic_index ( self , block_extrinsics : list , extrinsic_hash : str ) -> int : \"\"\" Returns the index of a provided extrinsic \"\"\" for idx , extrinsics in enumerate ( block_extrinsics ): ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return - 1 def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ) . digest () . hex () ) def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ) . get ( \"header\" ) . get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ) . get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {}) . get ( \"result\" , {}) . get ( \"finalized\" ) ) def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ], watch = True ) if \"error\" in str ( node_response ): return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ]) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ]) if not getkeys_response . get ( \"result\" , False ): response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ]: storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ])[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item [ 178 :]] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction class Kusama ( SubstrateBase ): def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ): self . chain = \"kusama\" self . address_type = 2 self . max_weight = 190949000 self . welfare_value = 4000000000 # 0.004 KSM super ( Kusama , self ) . __init__ ( node_url = node_url , arbitrator_key = arbitrator_key ) class Polkadot ( SubstrateBase ): def __init__ ( self , * , node_url : str = \"wss://rpc.polkadot.io/\" , arbitrator_key : str = None , ): self . chain = \"polkadot\" self . address_type = 0 self . max_weight = 648378000 self . welfare_value = 400000000 # 0.04 DOT super ( Polkadot , self ) . __init__ ( node_url = node_url , arbitrator_key = arbitrator_key ) class Kulupu ( SubstrateBase ): def __init__ ( self , * , node_url : str = \"wss://rpc.kulupu.corepaper.org/ws\" , arbitrator_key : str = None , ): self . chain = \"kulupu\" self . address_type = 16 super ( Kulupu , self ) . __init__ ( node_url = node_url , arbitrator_key = arbitrator_key ) def update_registry (): update_type_registries ()","title":"Module substrateutils.cores"},{"location":"reference/substrateutils/cores/#variables","text":"logger","title":"Variables"},{"location":"reference/substrateutils/cores/#functions","text":"","title":"Functions"},{"location":"reference/substrateutils/cores/#update_registry","text":"def update_registry ( ) View Source def update_registry () : update_type_registries ()","title":"update_registry"},{"location":"reference/substrateutils/cores/#classes","text":"","title":"Classes"},{"location":"reference/substrateutils/cores/#kulupu","text":"class Kulupu ( * , node_url : str = 'wss://rpc.kulupu.corepaper.org/ws' , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class Kulupu ( SubstrateBase ): def __init__ ( self , *, node_url: str = \"wss://rpc.kulupu.corepaper.org/ws\" , arbitrator_key: str = None , ): self . chain = \"kulupu\" self . address_type = 16 super ( Kulupu , self ). __init__ ( node_url = node_url , arbitrator_key = arbitrator_key )","title":"Kulupu"},{"location":"reference/substrateutils/cores/#ancestors-in-mro","text":"substrateutils.cores.SubstrateBase substrateutils.nonce.NonceManager abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/substrateutils/cores/#methods","text":"","title":"Methods"},{"location":"reference/substrateutils/cores/#arbitrator_nonce","text":"def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"arbitrator_nonce"},{"location":"reference/substrateutils/cores/#as_multi_payload","text":"def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce","title":"as_multi_payload"},{"location":"reference/substrateutils/cores/#as_multi_storage","text":"def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 ) View Source def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction","title":"as_multi_storage"},{"location":"reference/substrateutils/cores/#broadcast","text":"def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) if \"error\" in str ( node_response ) : return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response","title":"broadcast"},{"location":"reference/substrateutils/cores/#connect","text":"def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash ()","title":"connect"},{"location":"reference/substrateutils/cores/#diagnose","text":"def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response","title":"diagnose"},{"location":"reference/substrateutils/cores/#dump_metadata","text":"def dump_metadata ( self , filename : str = 'metadata.txt' ) -> None Dump the raw metadata to a file in root directory View Source def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata )","title":"dump_metadata"},{"location":"reference/substrateutils/cores/#escrow_payloads","text":"def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce","title":"escrow_payloads"},{"location":"reference/substrateutils/cores/#fee_return_transaction","text":"def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int ) -> str View Source def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction","title":"fee_return_transaction"},{"location":"reference/substrateutils/cores/#get_balance","text":"def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ]","title":"get_balance"},{"location":"reference/substrateutils/cores/#get_block","text":"def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response","title":"get_block"},{"location":"reference/substrateutils/cores/#get_block_hash","text":"def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node response View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) )","title":"get_block_hash"},{"location":"reference/substrateutils/cores/#get_escrow_address","text":"def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address","title":"get_escrow_address"},{"location":"reference/substrateutils/cores/#get_events","text":"def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode ()","title":"get_events"},{"location":"reference/substrateutils/cores/#get_extrinsic_events","text":"def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events","title":"get_extrinsic_events"},{"location":"reference/substrateutils/cores/#get_extrinsic_hash","text":"def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () )","title":"get_extrinsic_hash"},{"location":"reference/substrateutils/cores/#get_extrinsic_timepoint","text":"def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index )","title":"get_extrinsic_timepoint"},{"location":"reference/substrateutils/cores/#get_genesis_hash","text":"def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ]","title":"get_genesis_hash"},{"location":"reference/substrateutils/cores/#get_mempool_nonce","text":"def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce","title":"get_mempool_nonce"},{"location":"reference/substrateutils/cores/#get_metadata","text":"def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata","title":"get_metadata"},{"location":"reference/substrateutils/cores/#get_nonce","text":"def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ]","title":"get_nonce"},{"location":"reference/substrateutils/cores/#get_pending_extrinsics","text":"def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics","title":"get_pending_extrinsics"},{"location":"reference/substrateutils/cores/#is_transaction_success","text":"def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful","title":"is_transaction_success"},{"location":"reference/substrateutils/cores/#load_type_registry","text":"def load_type_registry ( self ) View Source def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config","title":"load_type_registry"},{"location":"reference/substrateutils/cores/#publish","text":"def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction )","title":"publish"},{"location":"reference/substrateutils/cores/#runtime_info","text":"def runtime_info ( self ) -> int Check the current runtime and load the correct spec vesion and transaction version View Source def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ]","title":"runtime_info"},{"location":"reference/substrateutils/cores/#setup_arbitrator","text":"def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type )","title":"setup_arbitrator"},{"location":"reference/substrateutils/cores/#transfer_payload","text":"def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , )","title":"transfer_payload"},{"location":"reference/substrateutils/cores/#welfare_transaction","text":"def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ) -> str View Source def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction","title":"welfare_transaction"},{"location":"reference/substrateutils/cores/#kusama","text":"class Kusama ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class Kusama ( SubstrateBase ): def __init__ ( self , *, node_url: str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key: str = None , ): self . chain = \"kusama\" self . address_type = 2 self . max_weight = 190949000 self . welfare_value = 4000000000 # 0.004 KSM super ( Kusama , self ). __init__ ( node_url = node_url , arbitrator_key = arbitrator_key )","title":"Kusama"},{"location":"reference/substrateutils/cores/#ancestors-in-mro_1","text":"substrateutils.cores.SubstrateBase substrateutils.nonce.NonceManager abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/substrateutils/cores/#methods_1","text":"","title":"Methods"},{"location":"reference/substrateutils/cores/#arbitrator_nonce_1","text":"def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"arbitrator_nonce"},{"location":"reference/substrateutils/cores/#as_multi_payload_1","text":"def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce","title":"as_multi_payload"},{"location":"reference/substrateutils/cores/#as_multi_storage_1","text":"def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 ) View Source def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction","title":"as_multi_storage"},{"location":"reference/substrateutils/cores/#broadcast_1","text":"def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) if \"error\" in str ( node_response ) : return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response","title":"broadcast"},{"location":"reference/substrateutils/cores/#connect_1","text":"def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash ()","title":"connect"},{"location":"reference/substrateutils/cores/#diagnose_1","text":"def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response","title":"diagnose"},{"location":"reference/substrateutils/cores/#dump_metadata_1","text":"def dump_metadata ( self , filename : str = 'metadata.txt' ) -> None Dump the raw metadata to a file in root directory View Source def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata )","title":"dump_metadata"},{"location":"reference/substrateutils/cores/#escrow_payloads_1","text":"def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce","title":"escrow_payloads"},{"location":"reference/substrateutils/cores/#fee_return_transaction_1","text":"def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int ) -> str View Source def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction","title":"fee_return_transaction"},{"location":"reference/substrateutils/cores/#get_balance_1","text":"def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ]","title":"get_balance"},{"location":"reference/substrateutils/cores/#get_block_1","text":"def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response","title":"get_block"},{"location":"reference/substrateutils/cores/#get_block_hash_1","text":"def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node response View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) )","title":"get_block_hash"},{"location":"reference/substrateutils/cores/#get_escrow_address_1","text":"def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address","title":"get_escrow_address"},{"location":"reference/substrateutils/cores/#get_events_1","text":"def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode ()","title":"get_events"},{"location":"reference/substrateutils/cores/#get_extrinsic_events_1","text":"def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events","title":"get_extrinsic_events"},{"location":"reference/substrateutils/cores/#get_extrinsic_hash_1","text":"def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () )","title":"get_extrinsic_hash"},{"location":"reference/substrateutils/cores/#get_extrinsic_timepoint_1","text":"def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index )","title":"get_extrinsic_timepoint"},{"location":"reference/substrateutils/cores/#get_genesis_hash_1","text":"def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ]","title":"get_genesis_hash"},{"location":"reference/substrateutils/cores/#get_mempool_nonce_1","text":"def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce","title":"get_mempool_nonce"},{"location":"reference/substrateutils/cores/#get_metadata_1","text":"def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata","title":"get_metadata"},{"location":"reference/substrateutils/cores/#get_nonce_1","text":"def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ]","title":"get_nonce"},{"location":"reference/substrateutils/cores/#get_pending_extrinsics_1","text":"def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics","title":"get_pending_extrinsics"},{"location":"reference/substrateutils/cores/#is_transaction_success_1","text":"def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful","title":"is_transaction_success"},{"location":"reference/substrateutils/cores/#load_type_registry_1","text":"def load_type_registry ( self ) View Source def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config","title":"load_type_registry"},{"location":"reference/substrateutils/cores/#publish_1","text":"def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction )","title":"publish"},{"location":"reference/substrateutils/cores/#runtime_info_1","text":"def runtime_info ( self ) -> int Check the current runtime and load the correct spec vesion and transaction version View Source def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ]","title":"runtime_info"},{"location":"reference/substrateutils/cores/#setup_arbitrator_1","text":"def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type )","title":"setup_arbitrator"},{"location":"reference/substrateutils/cores/#transfer_payload_1","text":"def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , )","title":"transfer_payload"},{"location":"reference/substrateutils/cores/#welfare_transaction_1","text":"def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ) -> str View Source def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction","title":"welfare_transaction"},{"location":"reference/substrateutils/cores/#polkadot","text":"class Polkadot ( * , node_url : str = 'wss://rpc.polkadot.io/' , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class Polkadot ( SubstrateBase ): def __init__ ( self , *, node_url: str = \"wss://rpc.polkadot.io/\" , arbitrator_key: str = None , ): self . chain = \"polkadot\" self . address_type = 0 self . max_weight = 648378000 self . welfare_value = 400000000 # 0.04 DOT super ( Polkadot , self ). __init__ ( node_url = node_url , arbitrator_key = arbitrator_key )","title":"Polkadot"},{"location":"reference/substrateutils/cores/#ancestors-in-mro_2","text":"substrateutils.cores.SubstrateBase substrateutils.nonce.NonceManager abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/substrateutils/cores/#methods_2","text":"","title":"Methods"},{"location":"reference/substrateutils/cores/#arbitrator_nonce_2","text":"def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"arbitrator_nonce"},{"location":"reference/substrateutils/cores/#as_multi_payload_2","text":"def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce","title":"as_multi_payload"},{"location":"reference/substrateutils/cores/#as_multi_storage_2","text":"def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 ) View Source def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction","title":"as_multi_storage"},{"location":"reference/substrateutils/cores/#broadcast_2","text":"def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) if \"error\" in str ( node_response ) : return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response","title":"broadcast"},{"location":"reference/substrateutils/cores/#connect_2","text":"def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash ()","title":"connect"},{"location":"reference/substrateutils/cores/#diagnose_2","text":"def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response","title":"diagnose"},{"location":"reference/substrateutils/cores/#dump_metadata_2","text":"def dump_metadata ( self , filename : str = 'metadata.txt' ) -> None Dump the raw metadata to a file in root directory View Source def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata )","title":"dump_metadata"},{"location":"reference/substrateutils/cores/#escrow_payloads_2","text":"def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce","title":"escrow_payloads"},{"location":"reference/substrateutils/cores/#fee_return_transaction_2","text":"def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int ) -> str View Source def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction","title":"fee_return_transaction"},{"location":"reference/substrateutils/cores/#get_balance_2","text":"def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ]","title":"get_balance"},{"location":"reference/substrateutils/cores/#get_block_2","text":"def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response","title":"get_block"},{"location":"reference/substrateutils/cores/#get_block_hash_2","text":"def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node response View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) )","title":"get_block_hash"},{"location":"reference/substrateutils/cores/#get_escrow_address_2","text":"def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address","title":"get_escrow_address"},{"location":"reference/substrateutils/cores/#get_events_2","text":"def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode ()","title":"get_events"},{"location":"reference/substrateutils/cores/#get_extrinsic_events_2","text":"def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events","title":"get_extrinsic_events"},{"location":"reference/substrateutils/cores/#get_extrinsic_hash_2","text":"def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () )","title":"get_extrinsic_hash"},{"location":"reference/substrateutils/cores/#get_extrinsic_timepoint_2","text":"def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index )","title":"get_extrinsic_timepoint"},{"location":"reference/substrateutils/cores/#get_genesis_hash_2","text":"def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ]","title":"get_genesis_hash"},{"location":"reference/substrateutils/cores/#get_mempool_nonce_2","text":"def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce","title":"get_mempool_nonce"},{"location":"reference/substrateutils/cores/#get_metadata_2","text":"def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata","title":"get_metadata"},{"location":"reference/substrateutils/cores/#get_nonce_2","text":"def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ]","title":"get_nonce"},{"location":"reference/substrateutils/cores/#get_pending_extrinsics_2","text":"def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics","title":"get_pending_extrinsics"},{"location":"reference/substrateutils/cores/#is_transaction_success_2","text":"def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful","title":"is_transaction_success"},{"location":"reference/substrateutils/cores/#load_type_registry_2","text":"def load_type_registry ( self ) View Source def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config","title":"load_type_registry"},{"location":"reference/substrateutils/cores/#publish_2","text":"def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction )","title":"publish"},{"location":"reference/substrateutils/cores/#runtime_info_2","text":"def runtime_info ( self ) -> int Check the current runtime and load the correct spec vesion and transaction version View Source def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ]","title":"runtime_info"},{"location":"reference/substrateutils/cores/#setup_arbitrator_2","text":"def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type )","title":"setup_arbitrator"},{"location":"reference/substrateutils/cores/#transfer_payload_2","text":"def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , )","title":"transfer_payload"},{"location":"reference/substrateutils/cores/#welfare_transaction_2","text":"def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ) -> str View Source def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction","title":"welfare_transaction"},{"location":"reference/substrateutils/cores/#substratebase","text":"class SubstrateBase ( * , node_url : str = None , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class SubstrateBase ( NonceManager ): def __init__ ( self , * , node_url : str = None , arbitrator_key : str = None , ): self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type ) def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ])[ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata ) def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] def _get_address_info ( self , address : str ) -> dict : \"\"\" Returns information associated with provided address \"\"\" # Storage key: # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , self . address_type ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ])[ \"result\" ] if not result : return { \"nonce\" : 0 , \"refcount\" : 0 , \"data\" : { \"free\" : 0 , \"reserved\" : 0 , \"miscFrozen\" : 0 , \"feeFrozen\" : 0 }, } return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ])[ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ], 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ]): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key: # xxHash128(System) + xxHash128(Events) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode () def _get_extrinsic_index ( self , block_extrinsics : list , extrinsic_hash : str ) -> int : \"\"\" Returns the index of a provided extrinsic \"\"\" for idx , extrinsics in enumerate ( block_extrinsics ): ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return - 1 def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ) . digest () . hex () ) def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ) . get ( \"header\" ) . get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ) . get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {}) . get ( \"result\" , {}) . get ( \"finalized\" ) ) def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ], watch = True ) if \"error\" in str ( node_response ): return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ]) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ]) if not getkeys_response . get ( \"result\" , False ): response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ]: storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ])[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item [ 178 :]] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction","title":"SubstrateBase"},{"location":"reference/substrateutils/cores/#ancestors-in-mro_3","text":"substrateutils.nonce.NonceManager abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/substrateutils/cores/#descendants","text":"substrateutils.cores.Kusama substrateutils.cores.Polkadot substrateutils.cores.Kulupu","title":"Descendants"},{"location":"reference/substrateutils/cores/#methods_3","text":"","title":"Methods"},{"location":"reference/substrateutils/cores/#arbitrator_nonce_3","text":"def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"arbitrator_nonce"},{"location":"reference/substrateutils/cores/#as_multi_payload_3","text":"def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , store_call : bool = False , max_weight : int = 0 , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" if max_weight == 0 : max_weight = self . max_weight nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , max_weight = max_weight , store_call = store_call , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return as_multi_payload , nonce","title":"as_multi_payload"},{"location":"reference/substrateutils/cores/#as_multi_storage_3","text":"def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 ) View Source def as_multi_storage ( self , to_address : str , other_signatory : str , amount : str , store_call : bool = True , max_weight : int = 1 , ): if max_weight == 0 : max_weight = self . max_weight nonce = self . arbitrator_nonce () payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , amount , [ other_signatory , to_address ], None , store_call = store_call , max_weight = max_weight , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) signature = helper . sign_payload ( self . keypair , payload ) transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , signature , nonce , to_address , amount , None , [ other_signatory , to_address ], store_call = store_call , max_weight = max_weight , runtime_config = self . runtime_config , ) return transaction","title":"as_multi_storage"},{"location":"reference/substrateutils/cores/#broadcast_3","text":"def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) if \"error\" in str ( node_response ) : return False , node_response tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) response = { \"tx_hash\" : tx_hash , \"timepoint\" : timepoint , } return success , response","title":"broadcast"},{"location":"reference/substrateutils/cores/#connect_3","text":"def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () self . load_type_registry () self . metadata = self . get_metadata () self . runtime_info () self . genesis_hash = self . get_genesis_hash ()","title":"connect"},{"location":"reference/substrateutils/cores/#diagnose_3","text":"def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address, self.address_type)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , runtime_config = self . runtime_config , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response","title":"diagnose"},{"location":"reference/substrateutils/cores/#dump_metadata_3","text":"def dump_metadata ( self , filename : str = 'metadata.txt' ) -> None Dump the raw metadata to a file in root directory View Source def dump_metadata ( self , filename : str = \"metadata.txt\" ) -> None : \"\"\" Dump the raw metadata to a file in root directory \"\"\" with open ( filename , \"w\" ) as f : f . write ( self . raw_metadata )","title":"dump_metadata"},{"location":"reference/substrateutils/cores/#escrow_payloads_3","text":"def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) return escrow_payload , fee_payload , nonce","title":"escrow_payloads"},{"location":"reference/substrateutils/cores/#fee_return_transaction_3","text":"def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int ) -> str View Source def fee_return_transaction ( self , seller_address : str , trade_value : int , fee_value : int , ) -> str : nonce = self . arbitrator_nonce () fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce , seller_address , fee_value , runtime_config = self . runtime_config , ) return fee_revert_transaction","title":"fee_return_transaction"},{"location":"reference/substrateutils/cores/#get_balance_3","text":"def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ]","title":"get_balance"},{"location":"reference/substrateutils/cores/#get_block_3","text":"def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata , runtime_config = self . runtime_config , ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response","title":"get_block"},{"location":"reference/substrateutils/cores/#get_block_hash_3","text":"def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node response View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node response \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) )","title":"get_block_hash"},{"location":"reference/substrateutils/cores/#get_escrow_address_3","text":"def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = self . runtime_config . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 , ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), self . address_type ) return multi_sig_address","title":"get_escrow_address"},{"location":"reference/substrateutils/cores/#get_events_3","text":"def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , runtime_config = self . runtime_config , ) return return_decoder . decode ()","title":"get_events"},{"location":"reference/substrateutils/cores/#get_extrinsic_events_3","text":"def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events","title":"get_extrinsic_events"},{"location":"reference/substrateutils/cores/#get_extrinsic_hash_3","text":"def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () )","title":"get_extrinsic_hash"},{"location":"reference/substrateutils/cores/#get_extrinsic_timepoint_3","text":"def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index )","title":"get_extrinsic_timepoint"},{"location":"reference/substrateutils/cores/#get_genesis_hash_3","text":"def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ]","title":"get_genesis_hash"},{"location":"reference/substrateutils/cores/#get_mempool_nonce_3","text":"def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce","title":"get_mempool_nonce"},{"location":"reference/substrateutils/cores/#get_metadata_3","text":"def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] self . raw_metadata = raw_metadata metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata","title":"get_metadata"},{"location":"reference/substrateutils/cores/#get_nonce_3","text":"def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ]","title":"get_nonce"},{"location":"reference/substrateutils/cores/#get_pending_extrinsics_3","text":"def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata , runtime_config = self . runtime_config , ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics","title":"get_pending_extrinsics"},{"location":"reference/substrateutils/cores/#is_transaction_success_3","text":"def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and (( \"MultisigExecuted\" in event_names ) or ( \"NewMultisig\" in event_names )) else successful ) return successful","title":"is_transaction_success"},{"location":"reference/substrateutils/cores/#load_type_registry_3","text":"def load_type_registry ( self ) View Source def load_type_registry ( self ): runtime_config = RuntimeConfigurationObject () runtime_config . update_type_registry ( load_type_registry_preset ( \"default\" )) runtime_config . update_type_registry ( load_type_registry_preset ( self . chain )) self . runtime_config = runtime_config","title":"load_type_registry"},{"location":"reference/substrateutils/cores/#publish_3","text":"def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], runtime_config = self . runtime_config , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"as_multi\" : if params [ 7 ] == 0 : params [ 7 ] = self . max_weight transaction = helper . unsigned_as_multi_construction ( self . metadata , * params , runtime_config = self . runtime_config ) return self . broadcast ( type , transaction )","title":"publish"},{"location":"reference/substrateutils/cores/#runtime_info_3","text":"def runtime_info ( self ) -> int Check the current runtime and load the correct spec vesion and transaction version View Source def runtime_info ( self ) -> int : \"\"\" Check the current runtime and load the correct spec vesion and transaction version \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ]","title":"runtime_info"},{"location":"reference/substrateutils/cores/#setup_arbitrator_3","text":"def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], self . address_type )","title":"setup_arbitrator"},{"location":"reference/substrateutils/cores/#transfer_payload_3","text":"def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , )","title":"transfer_payload"},{"location":"reference/substrateutils/cores/#welfare_transaction_3","text":"def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ) -> str View Source def welfare_transaction ( self , buyer_address : str , welfare_value : int = 0 ,) -> str : if welfare_value == 0 : welfare_value = self . welfare_value nonce = self . arbitrator_nonce () welfare_payload = helper . transfer_signature_payload ( self . metadata , buyer_address , welfare_value , nonce , self . genesis_hash , self . spec_version , transaction_version = self . transaction_version , runtime_config = self . runtime_config , ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce , buyer_address , welfare_value , runtime_config = self . runtime_config , ) return welfare_transaction","title":"welfare_transaction"},{"location":"reference/substrateutils/helper/","text":"Module substrateutils.helper Helper functions - all functions in this file are pure with no side effects View Source \"\"\" Helper functions - all functions in this file are pure with no side effects \"\"\" from hashlib import blake2b from typing import Union import scalecodec import sr25519 import xxhash from scalecodec.base import RuntimeConfigurationObject from scalecodec.base import ScaleDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.utils.ss58 import ss58_decode def xx128 ( word : str ) -> str : \"\"\" Returns a xxh128 hash on provided word \"\"\" a = bytearray ( xxhash . xxh64 ( word , seed = 0 ) . digest ()) b = bytearray ( xxhash . xxh64 ( word , seed = 1 ) . digest ()) a . reverse () b . reverse () return f \"{a.hex()}{b.hex()}\" def get_prefix ( escrow_address : str , address_type : int = 2 ) -> str : \"\"\" Returns prefix containing the account ID of the address provided \"\"\" module_prefix = xx128 ( \"Multisig\" ) + xx128 ( \"Multisigs\" ) account_id = ss58_decode ( escrow_address , address_type ) storage_key = bytearray ( xxhash . xxh64 ( bytes . fromhex ( account_id ), seed = 0 ) . digest ()) storage_key . reverse () return f \"{module_prefix}{storage_key.hex()}{account_id}\" def hash_call ( call : \"scalecodec.types.Call\" ) -> str : \"\"\" Returns a hashed call \"\"\" call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" def transfer_signature_payload ( metadata : \"MetadataDecoder\" , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 3 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata , runtime_config = runtime_config ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" , runtime_config = runtime_config ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : Union [ tuple , bool ], threshold : int = 2 , tip : int = 0 , transaction_version : int = 3 , max_weight : int = 0 , store_call : bool = False , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned as_multi string \"\"\" as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata , runtime_config = runtime_config ) transfer = ScaleDecoder . get_decoder_class ( \"OpaqueCall\" , metadata = metadata , runtime_config = runtime_config ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) maybe_timepoint = ( { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]} if timepoint else None ) as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . value , \"maybe_timepoint\" : maybe_timepoint , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , \"store_call\" : store_call , \"max_weight\" : max_weight , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" , runtime_config = runtime_config ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def _extrinsic_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , call_function : str , call_module : str , call_arguments : dict , nonce : int , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into extrinsic object \"\"\" extrinsic = ScaleDecoder . get_decoder_class ( \"Extrinsic\" , metadata = metadata , runtime_config = runtime_config ) extrinsic . encode ( { \"account_id\" : account_id , \"signature_version\" : 1 , \"signature\" : signature , \"call_function\" : call_function , \"call_module\" : call_module , \"call_args\" : call_arguments , \"nonce\" : nonce , \"era\" : \"00\" , \"tip\" : tip , } ) print ( \"Extrinsic\" , str ( extrinsic . data )) return str ( extrinsic . data ) def unsigned_transfer_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into a transfer extrinsic object \"\"\" call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , runtime_config , ) def unsigned_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : Union [ tuple , bool ], other_signatories : list , max_weight : int = 0 , store_call : bool = False , threshold : int = 2 , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into an as_multi extrinsic object \"\"\" call_function = \"as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"OpaqueCall\" , metadata = metadata , runtime_config = runtime_config ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) maybe_timepoint = ( { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]} if timepoint else None ) call_arguments = { \"call\" : transfer . value , \"maybe_timepoint\" : maybe_timepoint , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , \"store_call\" : store_call , \"max_weight\" : max_weight , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , runtime_config , ) def sign_payload ( keypair : tuple , payload : str ) -> str : \"\"\" Sign payload with keypair and return a signed hex string \"\"\" if payload [ 0 : 2 ] == \"0x\" : payload = payload [ 2 :] signature = sr25519 . sign ( keypair , bytes . fromhex ( payload )) return signature . hex () def hex_to_bytes ( hex ) -> bytes : \"\"\" Generic hex to bytes conversion \"\"\" if hex [ 0 : 2 ] == \"0x\" : hex = hex [ 2 :] return bytes . fromhex ( hex ) Functions as_multi_signature_payload def as_multi_signature_payload ( metadata : 'MetadataDecoder' , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : Union [ tuple , bool ], threshold : int = 2 , tip : int = 0 , transaction_version : int = 3 , max_weight : int = 0 , store_call : bool = False , runtime_config : 'RuntimeConfigurationObject' = None ) -> str Turn parameters gathered through side effects into unsigned as_multi string View Source def as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : Union [ tuple , bool ], threshold : int = 2 , tip : int = 0 , transaction_version : int = 3 , max_weight : int = 0 , store_call : bool = False , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned as_multi string \"\"\" as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata , runtime_config = runtime_config ) transfer = ScaleDecoder . get_decoder_class ( \"OpaqueCall\" , metadata = metadata , runtime_config = runtime_config ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) maybe_timepoint = ( { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]} if timepoint else None ) as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . value , \"maybe_timepoint\" : maybe_timepoint , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , \"store_call\" : store_call , \"max_weight\" : max_weight , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" , runtime_config = runtime_config ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) get_prefix def get_prefix ( escrow_address : str , address_type : int = 2 ) -> str Returns prefix containing the account ID of the address provided View Source def get_prefix ( escrow_address : str , address_type : int = 2 ) -> str : \"\"\" Returns prefix containing the account ID of the address provided \"\"\" module_prefix = xx128 ( \"Multisig\" ) + xx128 ( \"Multisigs\" ) account_id = ss58_decode ( escrow_address , address_type ) storage_key = bytearray ( xxhash . xxh64 ( bytes . fromhex ( account_id ), seed = 0 ). digest ()) storage_key . reverse () return f \"{module_prefix}{storage_key.hex()}{account_id}\" hash_call def hash_call ( call : 'scalecodec.types.Call' ) -> str Returns a hashed call View Source def hash_call ( call : \"scalecodec.types.Call\" ) -> str : \"\"\" Returns a hashed call \"\"\" call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" hex_to_bytes def hex_to_bytes ( hex ) -> bytes Generic hex to bytes conversion View Source def hex_to_bytes ( hex ) -> bytes : \"\"\" Generic hex to bytes conversion \"\"\" if hex [ 0 : 2 ] == \"0x\" : hex = hex [ 2 :] return bytes . fromhex ( hex ) sign_payload def sign_payload ( keypair : tuple , payload : str ) -> str Sign payload with keypair and return a signed hex string View Source def sign_payload ( keypair : tuple , payload : str ) -> str : \"\"\" Sign payload with keypair and return a signed hex string \"\"\" if payload [ 0 : 2 ] == \"0x\" : payload = payload [ 2 :] signature = sr25519 . sign ( keypair , bytes . fromhex ( payload )) return signature . hex () transfer_signature_payload def transfer_signature_payload ( metadata : 'MetadataDecoder' , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 3 , runtime_config : 'RuntimeConfigurationObject' = None ) -> str Turn parameters gathered through side effects into unsigned transfer string View Source def transfer_signature_payload ( metadata : \"MetadataDecoder\" , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 3 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata , runtime_config = runtime_config ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" , runtime_config = runtime_config ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) unsigned_as_multi_construction def unsigned_as_multi_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : Union [ tuple , bool ], other_signatories : list , max_weight : int = 0 , store_call : bool = False , threshold : int = 2 , tip : int = 0 , runtime_config : 'RuntimeConfigurationObject' = None ) -> str Turn parameters gathered through side effects into an as_multi extrinsic object View Source def unsigned_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : Union [ tuple , bool ], other_signatories : list , max_weight : int = 0 , store_call : bool = False , threshold : int = 2 , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into an as_multi extrinsic object \"\"\" call_function = \"as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"OpaqueCall\" , metadata = metadata , runtime_config = runtime_config ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) maybe_timepoint = ( { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]} if timepoint else None ) call_arguments = { \"call\" : transfer . value , \"maybe_timepoint\" : maybe_timepoint , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , \"store_call\" : store_call , \"max_weight\" : max_weight , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , runtime_config , ) unsigned_transfer_construction def unsigned_transfer_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , runtime_config : 'RuntimeConfigurationObject' = None ) -> str Turn parameters gathered through side effects into a transfer extrinsic object View Source def unsigned_transfer_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into a transfer extrinsic object \"\"\" call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , runtime_config , ) xx128 def xx128 ( word : str ) -> str Returns a xxh128 hash on provided word View Source def xx128 ( word : str ) -> str : \"\"\" Returns a xxh128 hash on provided word \"\"\" a = bytearray ( xxhash . xxh64 ( word , seed = 0 ). digest ()) b = bytearray ( xxhash . xxh64 ( word , seed = 1 ). digest ()) a . reverse () b . reverse () return f \"{a.hex()}{b.hex()}\"","title":"Helper"},{"location":"reference/substrateutils/helper/#module-substrateutilshelper","text":"Helper functions - all functions in this file are pure with no side effects View Source \"\"\" Helper functions - all functions in this file are pure with no side effects \"\"\" from hashlib import blake2b from typing import Union import scalecodec import sr25519 import xxhash from scalecodec.base import RuntimeConfigurationObject from scalecodec.base import ScaleDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.utils.ss58 import ss58_decode def xx128 ( word : str ) -> str : \"\"\" Returns a xxh128 hash on provided word \"\"\" a = bytearray ( xxhash . xxh64 ( word , seed = 0 ) . digest ()) b = bytearray ( xxhash . xxh64 ( word , seed = 1 ) . digest ()) a . reverse () b . reverse () return f \"{a.hex()}{b.hex()}\" def get_prefix ( escrow_address : str , address_type : int = 2 ) -> str : \"\"\" Returns prefix containing the account ID of the address provided \"\"\" module_prefix = xx128 ( \"Multisig\" ) + xx128 ( \"Multisigs\" ) account_id = ss58_decode ( escrow_address , address_type ) storage_key = bytearray ( xxhash . xxh64 ( bytes . fromhex ( account_id ), seed = 0 ) . digest ()) storage_key . reverse () return f \"{module_prefix}{storage_key.hex()}{account_id}\" def hash_call ( call : \"scalecodec.types.Call\" ) -> str : \"\"\" Returns a hashed call \"\"\" call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" def transfer_signature_payload ( metadata : \"MetadataDecoder\" , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 3 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata , runtime_config = runtime_config ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" , runtime_config = runtime_config ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : Union [ tuple , bool ], threshold : int = 2 , tip : int = 0 , transaction_version : int = 3 , max_weight : int = 0 , store_call : bool = False , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned as_multi string \"\"\" as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata , runtime_config = runtime_config ) transfer = ScaleDecoder . get_decoder_class ( \"OpaqueCall\" , metadata = metadata , runtime_config = runtime_config ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) maybe_timepoint = ( { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]} if timepoint else None ) as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . value , \"maybe_timepoint\" : maybe_timepoint , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , \"store_call\" : store_call , \"max_weight\" : max_weight , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" , runtime_config = runtime_config ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def _extrinsic_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , call_function : str , call_module : str , call_arguments : dict , nonce : int , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into extrinsic object \"\"\" extrinsic = ScaleDecoder . get_decoder_class ( \"Extrinsic\" , metadata = metadata , runtime_config = runtime_config ) extrinsic . encode ( { \"account_id\" : account_id , \"signature_version\" : 1 , \"signature\" : signature , \"call_function\" : call_function , \"call_module\" : call_module , \"call_args\" : call_arguments , \"nonce\" : nonce , \"era\" : \"00\" , \"tip\" : tip , } ) print ( \"Extrinsic\" , str ( extrinsic . data )) return str ( extrinsic . data ) def unsigned_transfer_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into a transfer extrinsic object \"\"\" call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , runtime_config , ) def unsigned_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : Union [ tuple , bool ], other_signatories : list , max_weight : int = 0 , store_call : bool = False , threshold : int = 2 , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into an as_multi extrinsic object \"\"\" call_function = \"as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"OpaqueCall\" , metadata = metadata , runtime_config = runtime_config ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) maybe_timepoint = ( { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]} if timepoint else None ) call_arguments = { \"call\" : transfer . value , \"maybe_timepoint\" : maybe_timepoint , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , \"store_call\" : store_call , \"max_weight\" : max_weight , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , runtime_config , ) def sign_payload ( keypair : tuple , payload : str ) -> str : \"\"\" Sign payload with keypair and return a signed hex string \"\"\" if payload [ 0 : 2 ] == \"0x\" : payload = payload [ 2 :] signature = sr25519 . sign ( keypair , bytes . fromhex ( payload )) return signature . hex () def hex_to_bytes ( hex ) -> bytes : \"\"\" Generic hex to bytes conversion \"\"\" if hex [ 0 : 2 ] == \"0x\" : hex = hex [ 2 :] return bytes . fromhex ( hex )","title":"Module substrateutils.helper"},{"location":"reference/substrateutils/helper/#functions","text":"","title":"Functions"},{"location":"reference/substrateutils/helper/#as_multi_signature_payload","text":"def as_multi_signature_payload ( metadata : 'MetadataDecoder' , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : Union [ tuple , bool ], threshold : int = 2 , tip : int = 0 , transaction_version : int = 3 , max_weight : int = 0 , store_call : bool = False , runtime_config : 'RuntimeConfigurationObject' = None ) -> str Turn parameters gathered through side effects into unsigned as_multi string View Source def as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : Union [ tuple , bool ], threshold : int = 2 , tip : int = 0 , transaction_version : int = 3 , max_weight : int = 0 , store_call : bool = False , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned as_multi string \"\"\" as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata , runtime_config = runtime_config ) transfer = ScaleDecoder . get_decoder_class ( \"OpaqueCall\" , metadata = metadata , runtime_config = runtime_config ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) maybe_timepoint = ( { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]} if timepoint else None ) as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . value , \"maybe_timepoint\" : maybe_timepoint , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , \"store_call\" : store_call , \"max_weight\" : max_weight , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" , runtime_config = runtime_config ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"as_multi_signature_payload"},{"location":"reference/substrateutils/helper/#get_prefix","text":"def get_prefix ( escrow_address : str , address_type : int = 2 ) -> str Returns prefix containing the account ID of the address provided View Source def get_prefix ( escrow_address : str , address_type : int = 2 ) -> str : \"\"\" Returns prefix containing the account ID of the address provided \"\"\" module_prefix = xx128 ( \"Multisig\" ) + xx128 ( \"Multisigs\" ) account_id = ss58_decode ( escrow_address , address_type ) storage_key = bytearray ( xxhash . xxh64 ( bytes . fromhex ( account_id ), seed = 0 ). digest ()) storage_key . reverse () return f \"{module_prefix}{storage_key.hex()}{account_id}\"","title":"get_prefix"},{"location":"reference/substrateutils/helper/#hash_call","text":"def hash_call ( call : 'scalecodec.types.Call' ) -> str Returns a hashed call View Source def hash_call ( call : \"scalecodec.types.Call\" ) -> str : \"\"\" Returns a hashed call \"\"\" call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\"","title":"hash_call"},{"location":"reference/substrateutils/helper/#hex_to_bytes","text":"def hex_to_bytes ( hex ) -> bytes Generic hex to bytes conversion View Source def hex_to_bytes ( hex ) -> bytes : \"\"\" Generic hex to bytes conversion \"\"\" if hex [ 0 : 2 ] == \"0x\" : hex = hex [ 2 :] return bytes . fromhex ( hex )","title":"hex_to_bytes"},{"location":"reference/substrateutils/helper/#sign_payload","text":"def sign_payload ( keypair : tuple , payload : str ) -> str Sign payload with keypair and return a signed hex string View Source def sign_payload ( keypair : tuple , payload : str ) -> str : \"\"\" Sign payload with keypair and return a signed hex string \"\"\" if payload [ 0 : 2 ] == \"0x\" : payload = payload [ 2 :] signature = sr25519 . sign ( keypair , bytes . fromhex ( payload )) return signature . hex ()","title":"sign_payload"},{"location":"reference/substrateutils/helper/#transfer_signature_payload","text":"def transfer_signature_payload ( metadata : 'MetadataDecoder' , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 3 , runtime_config : 'RuntimeConfigurationObject' = None ) -> str Turn parameters gathered through side effects into unsigned transfer string View Source def transfer_signature_payload ( metadata : \"MetadataDecoder\" , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 3 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata , runtime_config = runtime_config ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" , runtime_config = runtime_config ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"transfer_signature_payload"},{"location":"reference/substrateutils/helper/#unsigned_as_multi_construction","text":"def unsigned_as_multi_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : Union [ tuple , bool ], other_signatories : list , max_weight : int = 0 , store_call : bool = False , threshold : int = 2 , tip : int = 0 , runtime_config : 'RuntimeConfigurationObject' = None ) -> str Turn parameters gathered through side effects into an as_multi extrinsic object View Source def unsigned_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : Union [ tuple , bool ], other_signatories : list , max_weight : int = 0 , store_call : bool = False , threshold : int = 2 , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into an as_multi extrinsic object \"\"\" call_function = \"as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"OpaqueCall\" , metadata = metadata , runtime_config = runtime_config ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) maybe_timepoint = ( { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]} if timepoint else None ) call_arguments = { \"call\" : transfer . value , \"maybe_timepoint\" : maybe_timepoint , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , \"store_call\" : store_call , \"max_weight\" : max_weight , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , runtime_config , )","title":"unsigned_as_multi_construction"},{"location":"reference/substrateutils/helper/#unsigned_transfer_construction","text":"def unsigned_transfer_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , runtime_config : 'RuntimeConfigurationObject' = None ) -> str Turn parameters gathered through side effects into a transfer extrinsic object View Source def unsigned_transfer_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , runtime_config : \"RuntimeConfigurationObject\" = None , ) -> str : \"\"\" Turn parameters gathered through side effects into a transfer extrinsic object \"\"\" call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , runtime_config , )","title":"unsigned_transfer_construction"},{"location":"reference/substrateutils/helper/#xx128","text":"def xx128 ( word : str ) -> str Returns a xxh128 hash on provided word View Source def xx128 ( word : str ) -> str : \"\"\" Returns a xxh128 hash on provided word \"\"\" a = bytearray ( xxhash . xxh64 ( word , seed = 0 ). digest ()) b = bytearray ( xxhash . xxh64 ( word , seed = 1 ). digest ()) a . reverse () b . reverse () return f \"{a.hex()}{b.hex()}\"","title":"xx128"},{"location":"reference/substrateutils/network/","text":"Module substrateutils.network View Source import asyncio import json import logging import websockets logger = logging . getLogger ( __name__ ) class Network : \"\"\" The Network class manages a connection to local/remote Substrate node \"\"\" def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" ): logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution async def _node_rpc_call ( self , method , params , * , loop_limit : int = 0 ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised looping = ( False if ( ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ) or ( \"error\" in result ) ) else looping ) event_number += 1 await ws_request ( payload ) return ws_results Variables logger Classes Network class Network ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' ) The Network class manages a connection to local/remote Substrate node View Source class Network : \"\"\" The Network class manages a connection to local/remote Substrate node \"\"\" def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" ): logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution async def _node_rpc_call ( self , method , params , * , loop_limit : int = 0 ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised looping = ( False if ( ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ) or ( \"error\" in result ) ) else looping ) event_number += 1 await ws_request ( payload ) return ws_results Methods node_rpc_call def node_rpc_call ( self , method , params , watch : bool = False ) View Source def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution","title":"Network"},{"location":"reference/substrateutils/network/#module-substrateutilsnetwork","text":"View Source import asyncio import json import logging import websockets logger = logging . getLogger ( __name__ ) class Network : \"\"\" The Network class manages a connection to local/remote Substrate node \"\"\" def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" ): logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution async def _node_rpc_call ( self , method , params , * , loop_limit : int = 0 ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised looping = ( False if ( ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ) or ( \"error\" in result ) ) else looping ) event_number += 1 await ws_request ( payload ) return ws_results","title":"Module substrateutils.network"},{"location":"reference/substrateutils/network/#variables","text":"logger","title":"Variables"},{"location":"reference/substrateutils/network/#classes","text":"","title":"Classes"},{"location":"reference/substrateutils/network/#network","text":"class Network ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' ) The Network class manages a connection to local/remote Substrate node View Source class Network : \"\"\" The Network class manages a connection to local/remote Substrate node \"\"\" def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" ): logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution async def _node_rpc_call ( self , method , params , * , loop_limit : int = 0 ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised looping = ( False if ( ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ) or ( \"error\" in result ) ) else looping ) event_number += 1 await ws_request ( payload ) return ws_results","title":"Network"},{"location":"reference/substrateutils/network/#methods","text":"","title":"Methods"},{"location":"reference/substrateutils/network/#node_rpc_call","text":"def node_rpc_call ( self , method , params , watch : bool = False ) View Source def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution","title":"node_rpc_call"},{"location":"reference/substrateutils/nonce/","text":"Module substrateutils.nonce View Source from abc import ABC from abc import abstractmethod from scalecodec.utils.ss58 import ss58_decode class NonceManager ( ABC ): \"\"\" Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important \"\"\" @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" ) @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce Classes NonceManager class NonceManager ( / , * args , ** kwargs ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class NonceManager ( ABC ): \"\"\" Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important \"\"\" @ abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" ) @ abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce Ancestors (in MRO) abc.ABC Descendants substrateutils.cores.SubstrateBase Methods arbitrator_nonce def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce get_mempool_nonce def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce get_nonce def get_nonce ( self , address : str ) -> int View Source @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) get_pending_extrinsics def get_pending_extrinsics ( self ) -> list View Source @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" )","title":"Nonce"},{"location":"reference/substrateutils/nonce/#module-substrateutilsnonce","text":"View Source from abc import ABC from abc import abstractmethod from scalecodec.utils.ss58 import ss58_decode class NonceManager ( ABC ): \"\"\" Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important \"\"\" @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" ) @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"Module substrateutils.nonce"},{"location":"reference/substrateutils/nonce/#classes","text":"","title":"Classes"},{"location":"reference/substrateutils/nonce/#noncemanager","text":"class NonceManager ( / , * args , ** kwargs ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class NonceManager ( ABC ): \"\"\" Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important \"\"\" @ abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" ) @ abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"NonceManager"},{"location":"reference/substrateutils/nonce/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/substrateutils/nonce/#descendants","text":"substrateutils.cores.SubstrateBase","title":"Descendants"},{"location":"reference/substrateutils/nonce/#methods","text":"","title":"Methods"},{"location":"reference/substrateutils/nonce/#arbitrator_nonce","text":"def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"arbitrator_nonce"},{"location":"reference/substrateutils/nonce/#get_mempool_nonce","text":"def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce","title":"get_mempool_nonce"},{"location":"reference/substrateutils/nonce/#get_nonce","text":"def get_nonce ( self , address : str ) -> int View Source @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" )","title":"get_nonce"},{"location":"reference/substrateutils/nonce/#get_pending_extrinsics","text":"def get_pending_extrinsics ( self ) -> list View Source @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" )","title":"get_pending_extrinsics"},{"location":"reference/substrateutils/settings/","text":"Module substrateutils.settings","title":"Settings"},{"location":"reference/substrateutils/settings/#module-substrateutilssettings","text":"","title":"Module substrateutils.settings"},{"location":"reference/substrateutils/trades/","text":"Module substrateutils.trades View Source import bip39 import sr25519 from scalecodec.utils.ss58 import ss58_encode from .cores import Polkadot from .cores import SubstrateBase from .helper import sign_payload class User : def __init__ ( self , address_type = 0 , * , mnemonic = None , hex = None ): if mnemonic : seed_bytes = bip39 . bip39_to_mini_secret ( mnemonic , \"\" ) seed_hex = bytearray ( seed_bytes ) . hex () self . hex = seed_hex if hex : self . hex = hex self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( self . hex )) self . public_key = self . keypair [ 0 ] . hex () self . private_key = self . keypair [ 1 ] . hex () self . address = ss58_encode ( self . keypair [ 0 ], address_type ) class TradeManager : def __init__ ( self , buyer : \"User\" = None , seller : \"User\" = None , arbitrator : \"User\" = None , value : int = 0 , * , chain : \"SubstrateBase\" = None , fee_value : int = 1 , # % ): self . buyer = buyer self . seller = seller self . arbitrator = arbitrator if chain : core = chain else : core = Polkadot ( arbitrator_key = arbitrator . hex ) self . chain = core self . chain . connect () self . escrow_address = core . get_escrow_address ( self . buyer . address , self . seller . address ) self . value = value self . fee_value = fee_value self . status = \"CREATED\" def fund_escrow ( self ): escrow_payload , fee_payload , nonce = self . chain . escrow_payloads ( self . seller . address , self . escrow_address , self . value , self . fee_value , ) escrow_signature = sign_payload ( self . seller . keypair , escrow_payload ) fee_signature = sign_payload ( self . seller . keypair , fee_payload ) _ , self . escrow_tx = self . chain . publish ( \"transfer\" , [ self . seller . address , escrow_signature , nonce , self . escrow_address , self . value , ], ) _ , self . fee_tx = self . chain . publish ( \"fee_transfer\" , [ self . seller . address , fee_signature , nonce + 1 , self . fee_value ], ) self . status = \"FUNDED_ESCROW\" def release ( self ): transaction = self . chain . as_multi_storage ( self . buyer . address , self . seller . address , self . value , ) _ , self . release_arb_tx = self . chain . broadcast ( \"as_multi\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . buyer . address , self . value , [ self . buyer . address , self . arbitrator . address ], self . release_arb_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . release_seller = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . buyer . address , self . value , self . release_arb_tx [ \"timepoint\" ], [ self . buyer . address , self . arbitrator . address ], 0 , ], ) self . status = \"RELEASE\" def cancel ( self ): transaction = self . chain . as_multi_storage ( self . seller . address , self . buyer . address , self . value ) _ , self . cancel_tx = self . chain . broadcast ( \"as_multi\" , transaction ) transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . cancel_arb_tx = self . chain . broadcast ( \"transfer\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . seller . address , self . value , [ self . buyer . address , self . chain . arbitrator_address ], self . cancel_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . cancel_seller_tx = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . seller . address , self . value , self . cancel_tx [ \"timepoint\" ], [ self . buyer . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"CANCELLED\" def dispute ( self , winner = \"SELLER\" ): if winner == \"BUYER\" : to = self . buyer . address other = self . seller . address else : to = self . seller . address other = self . buyer . address transaction = self . chain . as_multi_storage ( to , other , self . value ) _ , self . dispute_arb = self . chain . broadcast ( \"as_multi\" , transaction ) if winner == \"BUYER\" : transaction = self . chain . welfare_transaction ( self . buyer . address ,) else : transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . dispute_special_tx = self . chain . broadcast ( \"transfer\" , transaction ) if winner == \"BUYER\" : to = self . buyer other = self . seller else : to = self . seller other = self . buyer as_multi_payload , nonce = self . chain . as_multi_payload ( to . address , to . address , self . value , [ other . address , self . chain . arbitrator_address ], self . dispute_arb [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( to . keypair , as_multi_payload ) _ , self . dispute_user_tx = self . chain . publish ( \"as_multi\" , [ to . address , as_multi_signature , nonce , to . address , self . value , self . dispute_arb [ \"timepoint\" ], [ other . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"DISPUTED\" Classes TradeManager class TradeManager ( buyer : 'User' = None , seller : 'User' = None , arbitrator : 'User' = None , value : int = 0 , * , chain : 'SubstrateBase' = None , fee_value : int = 1 ) View Source class TradeManager : def __init__ ( self , buyer : \"User\" = None , seller : \"User\" = None , arbitrator : \"User\" = None , value : int = 0 , * , chain : \"SubstrateBase\" = None , fee_value : int = 1 , # % ): self . buyer = buyer self . seller = seller self . arbitrator = arbitrator if chain : core = chain else : core = Polkadot ( arbitrator_key = arbitrator . hex ) self . chain = core self . chain . connect () self . escrow_address = core . get_escrow_address ( self . buyer . address , self . seller . address ) self . value = value self . fee_value = fee_value self . status = \"CREATED\" def fund_escrow ( self ): escrow_payload , fee_payload , nonce = self . chain . escrow_payloads ( self . seller . address , self . escrow_address , self . value , self . fee_value , ) escrow_signature = sign_payload ( self . seller . keypair , escrow_payload ) fee_signature = sign_payload ( self . seller . keypair , fee_payload ) _ , self . escrow_tx = self . chain . publish ( \"transfer\" , [ self . seller . address , escrow_signature , nonce , self . escrow_address , self . value , ], ) _ , self . fee_tx = self . chain . publish ( \"fee_transfer\" , [ self . seller . address , fee_signature , nonce + 1 , self . fee_value ], ) self . status = \"FUNDED_ESCROW\" def release ( self ): transaction = self . chain . as_multi_storage ( self . buyer . address , self . seller . address , self . value , ) _ , self . release_arb_tx = self . chain . broadcast ( \"as_multi\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . buyer . address , self . value , [ self . buyer . address , self . arbitrator . address ], self . release_arb_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . release_seller = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . buyer . address , self . value , self . release_arb_tx [ \"timepoint\" ], [ self . buyer . address , self . arbitrator . address ], 0 , ], ) self . status = \"RELEASE\" def cancel ( self ): transaction = self . chain . as_multi_storage ( self . seller . address , self . buyer . address , self . value ) _ , self . cancel_tx = self . chain . broadcast ( \"as_multi\" , transaction ) transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . cancel_arb_tx = self . chain . broadcast ( \"transfer\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . seller . address , self . value , [ self . buyer . address , self . chain . arbitrator_address ], self . cancel_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . cancel_seller_tx = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . seller . address , self . value , self . cancel_tx [ \"timepoint\" ], [ self . buyer . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"CANCELLED\" def dispute ( self , winner = \"SELLER\" ): if winner == \"BUYER\" : to = self . buyer . address other = self . seller . address else : to = self . seller . address other = self . buyer . address transaction = self . chain . as_multi_storage ( to , other , self . value ) _ , self . dispute_arb = self . chain . broadcast ( \"as_multi\" , transaction ) if winner == \"BUYER\" : transaction = self . chain . welfare_transaction ( self . buyer . address ,) else : transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . dispute_special_tx = self . chain . broadcast ( \"transfer\" , transaction ) if winner == \"BUYER\" : to = self . buyer other = self . seller else : to = self . seller other = self . buyer as_multi_payload , nonce = self . chain . as_multi_payload ( to . address , to . address , self . value , [ other . address , self . chain . arbitrator_address ], self . dispute_arb [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( to . keypair , as_multi_payload ) _ , self . dispute_user_tx = self . chain . publish ( \"as_multi\" , [ to . address , as_multi_signature , nonce , to . address , self . value , self . dispute_arb [ \"timepoint\" ], [ other . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"DISPUTED\" Methods cancel def cancel ( self ) View Source def cancel ( self ): transaction = self . chain . as_multi_storage ( self . seller . address , self . buyer . address , self . value ) _ , self . cancel_tx = self . chain . broadcast ( \"as_multi\" , transaction ) transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . cancel_arb_tx = self . chain . broadcast ( \"transfer\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . seller . address , self . value , [ self . buyer . address , self . chain . arbitrator_address ], self . cancel_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . cancel_seller_tx = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . seller . address , self . value , self . cancel_tx [ \"timepoint\" ], [ self . buyer . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"CANCELLED\" dispute def dispute ( self , winner = 'SELLER' ) View Source def dispute ( self , winner = \"SELLER\" ): if winner == \"BUYER\" : to = self . buyer . address other = self . seller . address else : to = self . seller . address other = self . buyer . address transaction = self . chain . as_multi_storage ( to , other , self . value ) _ , self . dispute_arb = self . chain . broadcast ( \"as_multi\" , transaction ) if winner == \"BUYER\" : transaction = self . chain . welfare_transaction ( self . buyer . address ,) else : transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . dispute_special_tx = self . chain . broadcast ( \"transfer\" , transaction ) if winner == \"BUYER\" : to = self . buyer other = self . seller else : to = self . seller other = self . buyer as_multi_payload , nonce = self . chain . as_multi_payload ( to . address , to . address , self . value , [ other . address , self . chain . arbitrator_address ], self . dispute_arb [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( to . keypair , as_multi_payload ) _ , self . dispute_user_tx = self . chain . publish ( \"as_multi\" , [ to . address , as_multi_signature , nonce , to . address , self . value , self . dispute_arb [ \"timepoint\" ], [ other . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"DISPUTED\" fund_escrow def fund_escrow ( self ) View Source def fund_escrow ( self ): escrow_payload , fee_payload , nonce = self . chain . escrow_payloads ( self . seller . address , self . escrow_address , self . value , self . fee_value , ) escrow_signature = sign_payload ( self . seller . keypair , escrow_payload ) fee_signature = sign_payload ( self . seller . keypair , fee_payload ) _ , self . escrow_tx = self . chain . publish ( \"transfer\" , [ self . seller . address , escrow_signature , nonce , self . escrow_address , self . value , ], ) _ , self . fee_tx = self . chain . publish ( \"fee_transfer\" , [ self . seller . address , fee_signature , nonce + 1 , self . fee_value ], ) self . status = \"FUNDED_ESCROW\" release def release ( self ) View Source def release ( self ): transaction = self . chain . as_multi_storage ( self . buyer . address , self . seller . address , self . value , ) _ , self . release_arb_tx = self . chain . broadcast ( \"as_multi\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . buyer . address , self . value , [ self . buyer . address , self . arbitrator . address ], self . release_arb_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . release_seller = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . buyer . address , self . value , self . release_arb_tx [ \"timepoint\" ], [ self . buyer . address , self . arbitrator . address ], 0 , ], ) self . status = \"RELEASE\" User class User ( address_type = 0 , * , mnemonic = None , hex = None ) View Source class User: def __init__ ( self , address_type = 0 , *, mnemonic = None , hex = None ): if mnemonic: seed_bytes = bip39 . bip39_to_mini_secret ( mnemonic , \"\" ) seed_hex = bytearray ( seed_bytes ). hex () self . hex = seed_hex if hex: self . hex = hex self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( self . hex )) self . public_key = self . keypair [ 0 ]. hex () self . private_key = self . keypair [ 1 ]. hex () self . address = ss58_encode ( self . keypair [ 0 ], address_type )","title":"Trades"},{"location":"reference/substrateutils/trades/#module-substrateutilstrades","text":"View Source import bip39 import sr25519 from scalecodec.utils.ss58 import ss58_encode from .cores import Polkadot from .cores import SubstrateBase from .helper import sign_payload class User : def __init__ ( self , address_type = 0 , * , mnemonic = None , hex = None ): if mnemonic : seed_bytes = bip39 . bip39_to_mini_secret ( mnemonic , \"\" ) seed_hex = bytearray ( seed_bytes ) . hex () self . hex = seed_hex if hex : self . hex = hex self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( self . hex )) self . public_key = self . keypair [ 0 ] . hex () self . private_key = self . keypair [ 1 ] . hex () self . address = ss58_encode ( self . keypair [ 0 ], address_type ) class TradeManager : def __init__ ( self , buyer : \"User\" = None , seller : \"User\" = None , arbitrator : \"User\" = None , value : int = 0 , * , chain : \"SubstrateBase\" = None , fee_value : int = 1 , # % ): self . buyer = buyer self . seller = seller self . arbitrator = arbitrator if chain : core = chain else : core = Polkadot ( arbitrator_key = arbitrator . hex ) self . chain = core self . chain . connect () self . escrow_address = core . get_escrow_address ( self . buyer . address , self . seller . address ) self . value = value self . fee_value = fee_value self . status = \"CREATED\" def fund_escrow ( self ): escrow_payload , fee_payload , nonce = self . chain . escrow_payloads ( self . seller . address , self . escrow_address , self . value , self . fee_value , ) escrow_signature = sign_payload ( self . seller . keypair , escrow_payload ) fee_signature = sign_payload ( self . seller . keypair , fee_payload ) _ , self . escrow_tx = self . chain . publish ( \"transfer\" , [ self . seller . address , escrow_signature , nonce , self . escrow_address , self . value , ], ) _ , self . fee_tx = self . chain . publish ( \"fee_transfer\" , [ self . seller . address , fee_signature , nonce + 1 , self . fee_value ], ) self . status = \"FUNDED_ESCROW\" def release ( self ): transaction = self . chain . as_multi_storage ( self . buyer . address , self . seller . address , self . value , ) _ , self . release_arb_tx = self . chain . broadcast ( \"as_multi\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . buyer . address , self . value , [ self . buyer . address , self . arbitrator . address ], self . release_arb_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . release_seller = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . buyer . address , self . value , self . release_arb_tx [ \"timepoint\" ], [ self . buyer . address , self . arbitrator . address ], 0 , ], ) self . status = \"RELEASE\" def cancel ( self ): transaction = self . chain . as_multi_storage ( self . seller . address , self . buyer . address , self . value ) _ , self . cancel_tx = self . chain . broadcast ( \"as_multi\" , transaction ) transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . cancel_arb_tx = self . chain . broadcast ( \"transfer\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . seller . address , self . value , [ self . buyer . address , self . chain . arbitrator_address ], self . cancel_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . cancel_seller_tx = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . seller . address , self . value , self . cancel_tx [ \"timepoint\" ], [ self . buyer . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"CANCELLED\" def dispute ( self , winner = \"SELLER\" ): if winner == \"BUYER\" : to = self . buyer . address other = self . seller . address else : to = self . seller . address other = self . buyer . address transaction = self . chain . as_multi_storage ( to , other , self . value ) _ , self . dispute_arb = self . chain . broadcast ( \"as_multi\" , transaction ) if winner == \"BUYER\" : transaction = self . chain . welfare_transaction ( self . buyer . address ,) else : transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . dispute_special_tx = self . chain . broadcast ( \"transfer\" , transaction ) if winner == \"BUYER\" : to = self . buyer other = self . seller else : to = self . seller other = self . buyer as_multi_payload , nonce = self . chain . as_multi_payload ( to . address , to . address , self . value , [ other . address , self . chain . arbitrator_address ], self . dispute_arb [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( to . keypair , as_multi_payload ) _ , self . dispute_user_tx = self . chain . publish ( \"as_multi\" , [ to . address , as_multi_signature , nonce , to . address , self . value , self . dispute_arb [ \"timepoint\" ], [ other . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"DISPUTED\"","title":"Module substrateutils.trades"},{"location":"reference/substrateutils/trades/#classes","text":"","title":"Classes"},{"location":"reference/substrateutils/trades/#trademanager","text":"class TradeManager ( buyer : 'User' = None , seller : 'User' = None , arbitrator : 'User' = None , value : int = 0 , * , chain : 'SubstrateBase' = None , fee_value : int = 1 ) View Source class TradeManager : def __init__ ( self , buyer : \"User\" = None , seller : \"User\" = None , arbitrator : \"User\" = None , value : int = 0 , * , chain : \"SubstrateBase\" = None , fee_value : int = 1 , # % ): self . buyer = buyer self . seller = seller self . arbitrator = arbitrator if chain : core = chain else : core = Polkadot ( arbitrator_key = arbitrator . hex ) self . chain = core self . chain . connect () self . escrow_address = core . get_escrow_address ( self . buyer . address , self . seller . address ) self . value = value self . fee_value = fee_value self . status = \"CREATED\" def fund_escrow ( self ): escrow_payload , fee_payload , nonce = self . chain . escrow_payloads ( self . seller . address , self . escrow_address , self . value , self . fee_value , ) escrow_signature = sign_payload ( self . seller . keypair , escrow_payload ) fee_signature = sign_payload ( self . seller . keypair , fee_payload ) _ , self . escrow_tx = self . chain . publish ( \"transfer\" , [ self . seller . address , escrow_signature , nonce , self . escrow_address , self . value , ], ) _ , self . fee_tx = self . chain . publish ( \"fee_transfer\" , [ self . seller . address , fee_signature , nonce + 1 , self . fee_value ], ) self . status = \"FUNDED_ESCROW\" def release ( self ): transaction = self . chain . as_multi_storage ( self . buyer . address , self . seller . address , self . value , ) _ , self . release_arb_tx = self . chain . broadcast ( \"as_multi\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . buyer . address , self . value , [ self . buyer . address , self . arbitrator . address ], self . release_arb_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . release_seller = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . buyer . address , self . value , self . release_arb_tx [ \"timepoint\" ], [ self . buyer . address , self . arbitrator . address ], 0 , ], ) self . status = \"RELEASE\" def cancel ( self ): transaction = self . chain . as_multi_storage ( self . seller . address , self . buyer . address , self . value ) _ , self . cancel_tx = self . chain . broadcast ( \"as_multi\" , transaction ) transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . cancel_arb_tx = self . chain . broadcast ( \"transfer\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . seller . address , self . value , [ self . buyer . address , self . chain . arbitrator_address ], self . cancel_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . cancel_seller_tx = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . seller . address , self . value , self . cancel_tx [ \"timepoint\" ], [ self . buyer . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"CANCELLED\" def dispute ( self , winner = \"SELLER\" ): if winner == \"BUYER\" : to = self . buyer . address other = self . seller . address else : to = self . seller . address other = self . buyer . address transaction = self . chain . as_multi_storage ( to , other , self . value ) _ , self . dispute_arb = self . chain . broadcast ( \"as_multi\" , transaction ) if winner == \"BUYER\" : transaction = self . chain . welfare_transaction ( self . buyer . address ,) else : transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . dispute_special_tx = self . chain . broadcast ( \"transfer\" , transaction ) if winner == \"BUYER\" : to = self . buyer other = self . seller else : to = self . seller other = self . buyer as_multi_payload , nonce = self . chain . as_multi_payload ( to . address , to . address , self . value , [ other . address , self . chain . arbitrator_address ], self . dispute_arb [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( to . keypair , as_multi_payload ) _ , self . dispute_user_tx = self . chain . publish ( \"as_multi\" , [ to . address , as_multi_signature , nonce , to . address , self . value , self . dispute_arb [ \"timepoint\" ], [ other . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"DISPUTED\"","title":"TradeManager"},{"location":"reference/substrateutils/trades/#methods","text":"","title":"Methods"},{"location":"reference/substrateutils/trades/#cancel","text":"def cancel ( self ) View Source def cancel ( self ): transaction = self . chain . as_multi_storage ( self . seller . address , self . buyer . address , self . value ) _ , self . cancel_tx = self . chain . broadcast ( \"as_multi\" , transaction ) transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . cancel_arb_tx = self . chain . broadcast ( \"transfer\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . seller . address , self . value , [ self . buyer . address , self . chain . arbitrator_address ], self . cancel_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . cancel_seller_tx = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . seller . address , self . value , self . cancel_tx [ \"timepoint\" ], [ self . buyer . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"CANCELLED\"","title":"cancel"},{"location":"reference/substrateutils/trades/#dispute","text":"def dispute ( self , winner = 'SELLER' ) View Source def dispute ( self , winner = \"SELLER\" ): if winner == \"BUYER\" : to = self . buyer . address other = self . seller . address else : to = self . seller . address other = self . buyer . address transaction = self . chain . as_multi_storage ( to , other , self . value ) _ , self . dispute_arb = self . chain . broadcast ( \"as_multi\" , transaction ) if winner == \"BUYER\" : transaction = self . chain . welfare_transaction ( self . buyer . address ,) else : transaction = self . chain . fee_return_transaction ( self . seller . address , self . value , self . fee_value , ) _ , self . dispute_special_tx = self . chain . broadcast ( \"transfer\" , transaction ) if winner == \"BUYER\" : to = self . buyer other = self . seller else : to = self . seller other = self . buyer as_multi_payload , nonce = self . chain . as_multi_payload ( to . address , to . address , self . value , [ other . address , self . chain . arbitrator_address ], self . dispute_arb [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( to . keypair , as_multi_payload ) _ , self . dispute_user_tx = self . chain . publish ( \"as_multi\" , [ to . address , as_multi_signature , nonce , to . address , self . value , self . dispute_arb [ \"timepoint\" ], [ other . address , self . chain . arbitrator_address ], 0 , ], ) self . status = \"DISPUTED\"","title":"dispute"},{"location":"reference/substrateutils/trades/#fund_escrow","text":"def fund_escrow ( self ) View Source def fund_escrow ( self ): escrow_payload , fee_payload , nonce = self . chain . escrow_payloads ( self . seller . address , self . escrow_address , self . value , self . fee_value , ) escrow_signature = sign_payload ( self . seller . keypair , escrow_payload ) fee_signature = sign_payload ( self . seller . keypair , fee_payload ) _ , self . escrow_tx = self . chain . publish ( \"transfer\" , [ self . seller . address , escrow_signature , nonce , self . escrow_address , self . value , ], ) _ , self . fee_tx = self . chain . publish ( \"fee_transfer\" , [ self . seller . address , fee_signature , nonce + 1 , self . fee_value ], ) self . status = \"FUNDED_ESCROW\"","title":"fund_escrow"},{"location":"reference/substrateutils/trades/#release","text":"def release ( self ) View Source def release ( self ): transaction = self . chain . as_multi_storage ( self . buyer . address , self . seller . address , self . value , ) _ , self . release_arb_tx = self . chain . broadcast ( \"as_multi\" , transaction ) as_multi_payload , nonce = self . chain . as_multi_payload ( self . seller . address , self . buyer . address , self . value , [ self . buyer . address , self . arbitrator . address ], self . release_arb_tx [ \"timepoint\" ], False , ) as_multi_signature = sign_payload ( self . seller . keypair , as_multi_payload ) _ , self . release_seller = self . chain . publish ( \"as_multi\" , [ self . seller . address , as_multi_signature , nonce , self . buyer . address , self . value , self . release_arb_tx [ \"timepoint\" ], [ self . buyer . address , self . arbitrator . address ], 0 , ], ) self . status = \"RELEASE\"","title":"release"},{"location":"reference/substrateutils/trades/#user","text":"class User ( address_type = 0 , * , mnemonic = None , hex = None ) View Source class User: def __init__ ( self , address_type = 0 , *, mnemonic = None , hex = None ): if mnemonic: seed_bytes = bip39 . bip39_to_mini_secret ( mnemonic , \"\" ) seed_hex = bytearray ( seed_bytes ). hex () self . hex = seed_hex if hex: self . hex = hex self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( self . hex )) self . public_key = self . keypair [ 0 ]. hex () self . private_key = self . keypair [ 1 ]. hex () self . address = ss58_encode ( self . keypair [ 0 ], address_type )","title":"User"}]}
