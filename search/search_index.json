{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kusama-utils Kusama utility library providing functionality for multi-signature trading, originally built for LocalCoinSwap Installation pip install ksmutils Quick start from ksmutils import Kusama kusama = Kusama () Documentation https://localcoinswap.github.io/kusama-utils/ Local development Pre-requisites Python 3.8.1 (preferred) We suggest using pyenv to easily manage python versions. Some of the following commands use pyenv . Use pyenv-installer for easy installation. Then add pyenv-virtualenv plugin to it. Configure local development setup Install and activate python 3.8.1 in the root directory pyenv install 3.8.1 pyenv virtualenv 3.8.1 ksmutils pyenv local ksmutils Install project requirements pip install -r requirements.txt Install precommit hook pre-commit install You're all set to hack! Before making changes, let's ensure tests run successfully on local. Running Tests Run all tests with coverage coverage run -m pytest -v Show report in terminal coverage report -m","title":"Home"},{"location":"#kusama-utils","text":"Kusama utility library providing functionality for multi-signature trading, originally built for LocalCoinSwap","title":"kusama-utils"},{"location":"#installation","text":"pip install ksmutils","title":"Installation"},{"location":"#quick-start","text":"from ksmutils import Kusama kusama = Kusama ()","title":"Quick start"},{"location":"#documentation","text":"https://localcoinswap.github.io/kusama-utils/","title":"Documentation"},{"location":"#local-development","text":"","title":"Local development"},{"location":"#pre-requisites","text":"Python 3.8.1 (preferred) We suggest using pyenv to easily manage python versions. Some of the following commands use pyenv . Use pyenv-installer for easy installation. Then add pyenv-virtualenv plugin to it.","title":"Pre-requisites"},{"location":"#configure-local-development-setup","text":"Install and activate python 3.8.1 in the root directory pyenv install 3.8.1 pyenv virtualenv 3.8.1 ksmutils pyenv local ksmutils Install project requirements pip install -r requirements.txt Install precommit hook pre-commit install You're all set to hack! Before making changes, let's ensure tests run successfully on local.","title":"Configure local development setup"},{"location":"#running-tests","text":"Run all tests with coverage coverage run -m pytest -v Show report in terminal coverage report -m","title":"Running Tests"},{"location":"docs/contributing/1.-local-development/","text":"Local Development Checklist before publishing the package Make sure to update REQUIRED and EXTRAS lists in setup.py based on what's required by the library and what's required only for development. To ease local development, we will continue to maintain requirements.txt which includes every package. Bump the version constant VERSION in setup.py Run setup test python setup.py test Publish package to PyPI python setup.py upload Generating Documentation Generate on local for testing portray server Publishing the docs to https://localcoinswap.github.io/kusama-utils/ Please make sure the docs look as expected on local Checkout to docs-branch branch git checkout docs-branch Only difference between master and docs-branch is that the site/ is not gitignored in docs-branch Merge master into docs-branch git merge master Add the merge commit Run portray as_html --overwrite (Read portray docs to know more) That will generate html docs in site/ directory, it will overwrite the existing content Commit the changes and push to docs-branch git add site/ git commit git push origin docs-branch Run this nested git command to publish the changes in gh-pages branch (which serves the static html) git push origin `git subtree split --prefix site docs-branch`:gh-pages --force","title":"1. Local Development"},{"location":"docs/contributing/1.-local-development/#local-development","text":"","title":"Local Development"},{"location":"docs/contributing/1.-local-development/#checklist-before-publishing-the-package","text":"Make sure to update REQUIRED and EXTRAS lists in setup.py based on what's required by the library and what's required only for development. To ease local development, we will continue to maintain requirements.txt which includes every package. Bump the version constant VERSION in setup.py Run setup test python setup.py test Publish package to PyPI python setup.py upload","title":"Checklist before publishing the package"},{"location":"docs/contributing/1.-local-development/#generating-documentation","text":"Generate on local for testing portray server Publishing the docs to https://localcoinswap.github.io/kusama-utils/ Please make sure the docs look as expected on local Checkout to docs-branch branch git checkout docs-branch Only difference between master and docs-branch is that the site/ is not gitignored in docs-branch Merge master into docs-branch git merge master Add the merge commit Run portray as_html --overwrite (Read portray docs to know more) That will generate html docs in site/ directory, it will overwrite the existing content Commit the changes and push to docs-branch git add site/ git commit git push origin docs-branch Run this nested git command to publish the changes in gh-pages branch (which serves the static html) git push origin `git subtree split --prefix site docs-branch`:gh-pages --force","title":"Generating Documentation"},{"location":"docs/examples/basic-usage/","text":"Basic setup of the module Instantiating without configuration from ksmutils import Kusama kusama = Kusama () Loading configuration after instantiation from ksmutils import Kusama kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' kusama . setup_arbitrator ( arbitrator_key ) Instantiating with arbitrator and websocket configuration from ksmutils import Kusama kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' node_provider = 'wss://kusama-rpc.polkadot.io/' kusama = Kusama ( arbitrator_key = arbitrator_key , node_url = node_provider ) Connecting to the Kusama blockchain kusama . connect () kusama . runtime_info ()","title":"Basic Usage"},{"location":"docs/examples/basic-usage/#basic-setup-of-the-module","text":"","title":"Basic setup of the module"},{"location":"docs/examples/basic-usage/#instantiating-without-configuration","text":"from ksmutils import Kusama kusama = Kusama ()","title":"Instantiating without configuration"},{"location":"docs/examples/basic-usage/#loading-configuration-after-instantiation","text":"from ksmutils import Kusama kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' kusama . setup_arbitrator ( arbitrator_key )","title":"Loading configuration after instantiation"},{"location":"docs/examples/basic-usage/#instantiating-with-arbitrator-and-websocket-configuration","text":"from ksmutils import Kusama kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' node_provider = 'wss://kusama-rpc.polkadot.io/' kusama = Kusama ( arbitrator_key = arbitrator_key , node_url = node_provider )","title":"Instantiating with arbitrator and websocket configuration"},{"location":"docs/examples/basic-usage/#connecting-to-the-kusama-blockchain","text":"kusama . connect () kusama . runtime_info ()","title":"Connecting to the Kusama blockchain"},{"location":"docs/examples/non-custodial-trades/","text":"Non-custodial trades using the utility module First, setup the module and connect to the Kusama blockchain using the instructions in the basic-usage section. You can now use the library to go through each step of the trading process. Please be aware of the distinction between user transactions and arbitrator transactions. User transactions need to be broadcast using the publish method, as there is construction required. Arbitrator transactions can be immediately broadcast using broadcast since they are already constructed. Generate an escrow address buyer_address = \"CofvaLbP3m8PLeNRQmLVPWmTT7jGgAXTwyT69k2wkfPxJ9V\" seller_address = \"D2bHQwFcQj11SvtkjULEdKhK4WAeP6MThXgosMHjW9DrmbE\" escrow_address = kusama . get_escrow_address ( buyer_address , seller_address ) Generate the signature payloads to fund the escrow and send the fee # Value of the trade in Plancks trade_value = 10000000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) fee_value = 100000000 escrow_payload , fee_payload , nonce = kusama . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value ) Sign the payloads import sr25519 from ksmutils.helper import sign_payload seller_key = '427a2c7cdff26fc2ab1dfda2ba991624cad12f8adc8b0851540db6efec2c7431' keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) escrow_signature = sign_payload ( keypair , escrow_payload ) fee_signature = sign_payload ( keypair , fee_payload ) Construct and broadcast the transactions escrow_tx_hash , escrow_timepoint , success = kusama . publish ( 'transfer' , [ seller_address , escrow_signature , nonce , escrow_address , trade_value ] ) assert success fee_tx_hash , fee_timepoint , success = kusama . publish ( 'fee_transfer' , [ seller_address , fee_signature , nonce + 1 , fee_value ] ) assert success Release the escrow to buyer # Seller broadcasts approve_as_multi for escrow approve_as_multi_payload , nonce = kusama . approve_as_multi_payload ( seller_address , buyer_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ) # Sign payload approve_as_multi_signature = sign_payload ( keypair , approve_as_multi_payload ) # Construct and broadcast seller approve_as_multi tx_hash , timepoint , success = kusama . publish ( 'approve_as_multi' , [ seller_address , approve_as_multi_signature , nonce , buyer_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ] ) assert success # Get arbitrator release escrow transaction and broadcast it as_multi = kusama . release_escrow ( buyer_address , trade_value , timepoint , [ seller_address , buyer_address ] ) tx_hash , timepoint , success = kusama . broadcast ( 'as_multi' , as_multi ) assert success Trade cancellation, return funds to seller # Seller broadcasts approve_as_multi for escrow return approve_as_multi_payload , nonce = kusama . approve_as_multi_payload ( seller_address , seller_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ) approve_as_multi_signature = sign_payload ( keypair , approve_as_multi_payload ) tx_hash , timepoint , success = kusama . publish ( 'approve_as_multi' , [ seller_address , approve_as_multi_signature , nonce , seller_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ] ) assert success # Get arbitrator cancellation transactions and broadcast them revert , fee_revert = kusama . cancellation ( seller_address , trade_value , fee_value , [ seller_address , buyer_address ], timepoint ) tx_hash , timepoint , success = kusama . broadcast ( 'as_multi' , revert ) assert success tx_hash , timepoint , success = kusama . broadcast ( 'transfer' , fee_revert ) assert success Note: in all dispute situations the arbitrator broadcasts first. For simplicity, we still broadcast as_multi if the seller wins, in order to reuse the business logic of cancellation. Buyer wins dispute # Get and broadcast the arbitrator transactions victor = \"buyer\" release_transaction , welfare_transaction = kusama . resolve_dispute ( victor , seller_address , trade_value , fee_value , [ buyer_address , seller_address ] ) tx_hash , escrow_timepoint , success = kusama . broadcast ( 'as_multi' , release_transaction ) assert success tx_hash , timepoint , success = kusama . broadcast ( 'transfer' , welfare_transaction ) assert success # Construct and broadcast the final buyer as_multi, seller or buyer can do this as_multi_payload , nonce = kusama . approve_as_multi_payload ( seller_address , seller_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ) as_multi_signature = sign_payload ( keypair , as_multi_payload ) tx_hash , timepoint , success = kusama . publish ( 'as_multi' , [ seller_address , as_multi_signature , nonce , seller_address , trade_value , [ buyer_address , kusama . arbitrator_address ], escrow_timepoint ] ) assert success End-to-end standard trade The following example is designed to show the execution logic over an entire trade. This is purposely verbose to eliminate confusion. import sr25519 from ksmutils import Kusama from ksmutils.helper import sign_payload kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' kusama . setup_arbitrator ( arbitrator_key ) kusama . connect () buyer_address = \"CofvaLbP3m8PLeNRQmLVPWmTT7jGgAXTwyT69k2wkfPxJ9V\" seller_address = \"D2bHQwFcQj11SvtkjULEdKhK4WAeP6MThXgosMHjW9DrmbE\" escrow_address = kusama . get_escrow_address ( buyer_address , seller_address ) # Value of the trade in Plancks trade_value = 10000000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) fee_value = 100000000 escrow_payload , fee_payload , nonce = kusama . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value ) seller_key = '427a2c7cdff26fc2ab1dfda2ba991624cad12f8adc8b0851540db6efec2c7431' keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) escrow_signature = sign_payload ( keypair , escrow_payload ) fee_signature = sign_payload ( keypair , fee_payload ) escrow_tx_hash , escrow_timepoint , success = kusama . publish ( 'transfer' , [ seller_address , escrow_signature , nonce , escrow_address , trade_value ] ) assert success fee_tx_hash , fee_timepoint , success = kusama . publish ( 'fee_transfer' , [ seller_address , fee_signature , nonce + 1 , fee_value ] ) assert success # Seller broadcasts approve_as_multi for escrow approve_as_multi_payload , nonce = kusama . approve_as_multi_payload ( seller_address , buyer_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ) # Sign payload approve_as_multi_signature = sign_payload ( keypair , approve_as_multi_payload ) # Construct and broadcast seller approve_as_multi tx_hash , timepoint , success = kusama . publish ( 'approve_as_multi' , [ seller_address , approve_as_multi_signature , nonce , buyer_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ] ) assert success # Get arbitrator release escrow transaction and broadcast it as_multi = kusama . release_escrow ( buyer_address , trade_value , timepoint , [ seller_address , buyer_address ] ) tx_hash , timepoint , success = kusama . broadcast ( 'as_multi' , as_multi ) assert success","title":"Non Custodial Trades"},{"location":"docs/examples/non-custodial-trades/#non-custodial-trades-using-the-utility-module","text":"First, setup the module and connect to the Kusama blockchain using the instructions in the basic-usage section. You can now use the library to go through each step of the trading process. Please be aware of the distinction between user transactions and arbitrator transactions. User transactions need to be broadcast using the publish method, as there is construction required. Arbitrator transactions can be immediately broadcast using broadcast since they are already constructed.","title":"Non-custodial trades using the utility module"},{"location":"docs/examples/non-custodial-trades/#generate-an-escrow-address","text":"buyer_address = \"CofvaLbP3m8PLeNRQmLVPWmTT7jGgAXTwyT69k2wkfPxJ9V\" seller_address = \"D2bHQwFcQj11SvtkjULEdKhK4WAeP6MThXgosMHjW9DrmbE\" escrow_address = kusama . get_escrow_address ( buyer_address , seller_address )","title":"Generate an escrow address"},{"location":"docs/examples/non-custodial-trades/#generate-the-signature-payloads-to-fund-the-escrow-and-send-the-fee","text":"# Value of the trade in Plancks trade_value = 10000000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) fee_value = 100000000 escrow_payload , fee_payload , nonce = kusama . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value )","title":"Generate the signature payloads to fund the escrow and send the fee"},{"location":"docs/examples/non-custodial-trades/#sign-the-payloads","text":"import sr25519 from ksmutils.helper import sign_payload seller_key = '427a2c7cdff26fc2ab1dfda2ba991624cad12f8adc8b0851540db6efec2c7431' keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) escrow_signature = sign_payload ( keypair , escrow_payload ) fee_signature = sign_payload ( keypair , fee_payload )","title":"Sign the payloads"},{"location":"docs/examples/non-custodial-trades/#construct-and-broadcast-the-transactions","text":"escrow_tx_hash , escrow_timepoint , success = kusama . publish ( 'transfer' , [ seller_address , escrow_signature , nonce , escrow_address , trade_value ] ) assert success fee_tx_hash , fee_timepoint , success = kusama . publish ( 'fee_transfer' , [ seller_address , fee_signature , nonce + 1 , fee_value ] ) assert success","title":"Construct and broadcast the transactions"},{"location":"docs/examples/non-custodial-trades/#release-the-escrow-to-buyer","text":"# Seller broadcasts approve_as_multi for escrow approve_as_multi_payload , nonce = kusama . approve_as_multi_payload ( seller_address , buyer_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ) # Sign payload approve_as_multi_signature = sign_payload ( keypair , approve_as_multi_payload ) # Construct and broadcast seller approve_as_multi tx_hash , timepoint , success = kusama . publish ( 'approve_as_multi' , [ seller_address , approve_as_multi_signature , nonce , buyer_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ] ) assert success # Get arbitrator release escrow transaction and broadcast it as_multi = kusama . release_escrow ( buyer_address , trade_value , timepoint , [ seller_address , buyer_address ] ) tx_hash , timepoint , success = kusama . broadcast ( 'as_multi' , as_multi ) assert success","title":"Release the escrow to buyer"},{"location":"docs/examples/non-custodial-trades/#trade-cancellation-return-funds-to-seller","text":"# Seller broadcasts approve_as_multi for escrow return approve_as_multi_payload , nonce = kusama . approve_as_multi_payload ( seller_address , seller_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ) approve_as_multi_signature = sign_payload ( keypair , approve_as_multi_payload ) tx_hash , timepoint , success = kusama . publish ( 'approve_as_multi' , [ seller_address , approve_as_multi_signature , nonce , seller_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ] ) assert success # Get arbitrator cancellation transactions and broadcast them revert , fee_revert = kusama . cancellation ( seller_address , trade_value , fee_value , [ seller_address , buyer_address ], timepoint ) tx_hash , timepoint , success = kusama . broadcast ( 'as_multi' , revert ) assert success tx_hash , timepoint , success = kusama . broadcast ( 'transfer' , fee_revert ) assert success Note: in all dispute situations the arbitrator broadcasts first. For simplicity, we still broadcast as_multi if the seller wins, in order to reuse the business logic of cancellation.","title":"Trade cancellation, return funds to seller"},{"location":"docs/examples/non-custodial-trades/#buyer-wins-dispute","text":"# Get and broadcast the arbitrator transactions victor = \"buyer\" release_transaction , welfare_transaction = kusama . resolve_dispute ( victor , seller_address , trade_value , fee_value , [ buyer_address , seller_address ] ) tx_hash , escrow_timepoint , success = kusama . broadcast ( 'as_multi' , release_transaction ) assert success tx_hash , timepoint , success = kusama . broadcast ( 'transfer' , welfare_transaction ) assert success # Construct and broadcast the final buyer as_multi, seller or buyer can do this as_multi_payload , nonce = kusama . approve_as_multi_payload ( seller_address , seller_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ) as_multi_signature = sign_payload ( keypair , as_multi_payload ) tx_hash , timepoint , success = kusama . publish ( 'as_multi' , [ seller_address , as_multi_signature , nonce , seller_address , trade_value , [ buyer_address , kusama . arbitrator_address ], escrow_timepoint ] ) assert success","title":"Buyer wins dispute"},{"location":"docs/examples/non-custodial-trades/#end-to-end-standard-trade","text":"The following example is designed to show the execution logic over an entire trade. This is purposely verbose to eliminate confusion. import sr25519 from ksmutils import Kusama from ksmutils.helper import sign_payload kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' kusama . setup_arbitrator ( arbitrator_key ) kusama . connect () buyer_address = \"CofvaLbP3m8PLeNRQmLVPWmTT7jGgAXTwyT69k2wkfPxJ9V\" seller_address = \"D2bHQwFcQj11SvtkjULEdKhK4WAeP6MThXgosMHjW9DrmbE\" escrow_address = kusama . get_escrow_address ( buyer_address , seller_address ) # Value of the trade in Plancks trade_value = 10000000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) fee_value = 100000000 escrow_payload , fee_payload , nonce = kusama . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value ) seller_key = '427a2c7cdff26fc2ab1dfda2ba991624cad12f8adc8b0851540db6efec2c7431' keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) escrow_signature = sign_payload ( keypair , escrow_payload ) fee_signature = sign_payload ( keypair , fee_payload ) escrow_tx_hash , escrow_timepoint , success = kusama . publish ( 'transfer' , [ seller_address , escrow_signature , nonce , escrow_address , trade_value ] ) assert success fee_tx_hash , fee_timepoint , success = kusama . publish ( 'fee_transfer' , [ seller_address , fee_signature , nonce + 1 , fee_value ] ) assert success # Seller broadcasts approve_as_multi for escrow approve_as_multi_payload , nonce = kusama . approve_as_multi_payload ( seller_address , buyer_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ) # Sign payload approve_as_multi_signature = sign_payload ( keypair , approve_as_multi_payload ) # Construct and broadcast seller approve_as_multi tx_hash , timepoint , success = kusama . publish ( 'approve_as_multi' , [ seller_address , approve_as_multi_signature , nonce , buyer_address , trade_value , [ buyer_address , kusama . arbitrator_address ] ] ) assert success # Get arbitrator release escrow transaction and broadcast it as_multi = kusama . release_escrow ( buyer_address , trade_value , timepoint , [ seller_address , buyer_address ] ) tx_hash , timepoint , success = kusama . broadcast ( 'as_multi' , as_multi ) assert success","title":"End-to-end standard trade"},{"location":"reference/ksmutils/","text":"Module ksmutils View Source from .core import Kusama from .network import Network __all__ = [ Kusama , Network ] Sub-modules ksmutils.core ksmutils.helper ksmutils.network ksmutils.settings","title":"Index"},{"location":"reference/ksmutils/#module-ksmutils","text":"View Source from .core import Kusama from .network import Network __all__ = [ Kusama , Network ]","title":"Module ksmutils"},{"location":"reference/ksmutils/#sub-modules","text":"ksmutils.core ksmutils.helper ksmutils.network ksmutils.settings","title":"Sub-modules"},{"location":"reference/ksmutils/core/","text":"Module ksmutils.core View Source import logging from abc import ABC from abc import abstractmethod from hashlib import blake2b import sr25519 from scalecodec import ScaleBytes from scalecodec.base import RuntimeConfiguration from scalecodec.base import ScaleDecoder from scalecodec.block import ExtrinsicsDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.type_registry import load_type_registry_preset from scalecodec.utils.ss58 import ss58_decode from scalecodec.utils.ss58 import ss58_encode from . import helper from .network import Network logger = logging . getLogger ( __name__ ) class NonceManager ( ABC ): \"\"\" Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important \"\"\" @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" ) @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce class Kusama ( NonceManager ): def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ): self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], 2 ) def runtime_info ( self ) -> int : \"\"\" Check the current \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ])[ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ) -> int : \"\"\" Returns the blockchain version \"\"\" return self . spec_version def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] def _get_address_info ( self , address : str ) -> dict : \"\"\" Returns information associated with provided address \"\"\" # Storage key: # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ])[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ])[ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ], 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ]): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key: # xxHash128(System) + xxHash128(Events) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def _get_extrinsic_index ( self , block_extrinsics : list , extrinsic_hash : str ) -> int : \"\"\" Returns the index of a provided extrinsic \"\"\" for idx , extrinsics in enumerate ( block_extrinsics ): ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return - 1 def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ) . digest () . hex () ) def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ) . get ( \"header\" ) . get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ) . get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration () . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , ) def approve_as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list ) -> tuple : \"\"\" Returns signature payloads for approve_as_multi \"\"\" nonce = self . get_nonce ( from_address ) approve_as_multi_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , ) return approve_as_multi_payload , nonce def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , ) return as_multi_payload , nonce def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload , nonce def release_escrow ( self , buyer_address : str , trade_value : int , timepoint : tuple , other_signatories : list , ) -> str : \"\"\" Return final arbitrator as_multi transaction for releasing escrow \"\"\" nonce = self . arbitrator_nonce () release_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , buyer_address , trade_value , other_signatories , timepoint , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) release_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , buyer_address , trade_value , timepoint , other_signatories , ) return release_transaction def cancellation ( self , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , timepoint : tuple , ) -> tuple : \"\"\" Return signed and ready transactions for the fee return and escrow return \"\"\" if fee_value > trade_value * 0.01 : raise Exception ( \"Fee should not be more than 1 % o f trade value\" ) nonce = self . arbitrator_nonce () revert_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , timepoint , ) fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) revert_signature = helper . sign_payload ( self . keypair , revert_payload ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) revert_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , revert_signature , nonce , seller_address , trade_value , timepoint , other_signatories , ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce + 1 , seller_address , fee_value , ) return revert_transaction , fee_revert_transaction def resolve_dispute ( self , victor : str , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , welfare_value : int = 1000000000 , ) -> tuple : \"\"\" If sellers wins then return cancellation logic If buyer wins then return ready approveAsMulti and ready buyer welfare transfer \"\"\" nonce = self . arbitrator_nonce () if victor == \"seller\" : return self . cancellation ( seller_address , trade_value , fee_value , other_signatories , None ) release_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) welfare_payload = helper . transfer_signature_payload ( self . metadata , seller_address , welfare_value , nonce + 1 , self . genesis_hash , self . spec_version , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) release_transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , seller_address , trade_value , other_signatories , ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce + 1 , seller_address , welfare_value , ) return release_transaction , welfare_transaction def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node responce \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {}) . get ( \"result\" , {}) . get ( \"finalized\" ) ) def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"approve_as_multi\" and \"NewMultisig\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and \"MultisigExecuted\" in event_names else successful ) return successful def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], ) return self . broadcast ( \"transfer\" , transaction ) if type == \"approve_as_multi\" : transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"as_multi\" : transaction = helper . unsigned_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ], watch = True ) tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ]) success = self . is_transaction_success ( type , events ) return tx_hash , timepoint , success def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ]) if not getkeys_response . get ( \"result\" , False ): response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ]: storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ])[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , ) response [ item [ 178 :]] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response Variables logger Classes Kusama class Kusama ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class Kusama ( NonceManager ) : def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ) : self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ) : \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key : str ) : \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ] , 2 ) def runtime_info ( self ) -> int : \"\"\" Check the current \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [] ) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ) -> int : \"\"\" Returns the blockchain version \"\"\" return self . spec_version def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ] ) [ \"result\" ] def _get_address_info ( self , address : str ) -> dict : \"\"\" Returns information associated with provided address \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Account ) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash, None ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash, block_hash ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def _get_extrinsic_index ( self , block_extrinsics : list , extrinsic_hash : str ) -> int : \"\"\" Returns the index of a provided extrinsic \"\"\" for idx , extrinsics in enumerate ( block_extrinsics ) : ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return - 1 def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2: ] ), digest_size = 32 ). digest (). hex () ) def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [] ) [ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration (). get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address, seller_address, self.arbitrator_address ] , 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , ) def approve_as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list ) -> tuple : \"\"\" Returns signature payloads for approve_as_multi \"\"\" nonce = self . get_nonce ( from_address ) approve_as_multi_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , ) return approve_as_multi_payload , nonce def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , ) return as_multi_payload , nonce def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload , nonce def release_escrow ( self , buyer_address : str , trade_value : int , timepoint : tuple , other_signatories : list , ) -> str : \"\"\" Return final arbitrator as_multi transaction for releasing escrow \"\"\" nonce = self . arbitrator_nonce () release_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , buyer_address , trade_value , other_signatories , timepoint , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) release_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , buyer_address , trade_value , timepoint , other_signatories , ) return release_transaction def cancellation ( self , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , timepoint : tuple , ) -> tuple : \"\"\" Return signed and ready transactions for the fee return and escrow return \"\"\" if fee_value > trade_value * 0.01 : raise Exception ( \"Fee should not be more than 1% of trade value\" ) nonce = self . arbitrator_nonce () revert_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , timepoint , ) fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) revert_signature = helper . sign_payload ( self . keypair , revert_payload ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) revert_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , revert_signature , nonce , seller_address , trade_value , timepoint , other_signatories , ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce + 1 , seller_address , fee_value , ) return revert_transaction , fee_revert_transaction def resolve_dispute ( self , victor : str , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , welfare_value : int = 1000000000 , ) -> tuple : \"\"\" If sellers wins then return cancellation logic If buyer wins then return ready approveAsMulti and ready buyer welfare transfer \"\"\" nonce = self . arbitrator_nonce () if victor == \"seller\" : return self . cancellation ( seller_address , trade_value , fee_value , other_signatories , None ) release_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) welfare_payload = helper . transfer_signature_payload ( self . metadata , seller_address , welfare_value , nonce + 1 , self . genesis_hash , self . spec_version , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) release_transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , seller_address , trade_value , other_signatories , ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce + 1 , seller_address , welfare_value , ) return release_transaction , welfare_transaction def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node responce \"\"\" return ( node_response [ max(node_response.keys()) ] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) ) def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ] ) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"approve_as_multi\" and \"NewMultisig\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and \"MultisigExecuted\" in event_names else successful ) return successful def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ] , params [ 1 ] , params [ 2 ] , self . arbitrator_address , params [ 3 ] , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"approve_as_multi\" : transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"as_multi\" : transaction = helper . unsigned_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) return tx_hash , timepoint , success def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response Ancestors (in MRO) ksmutils.core.NonceManager abc.ABC Methods approve_as_multi_payload def approve_as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list ) -> tuple Returns signature payloads for approve_as_multi View Source def approve_as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list ) -> tuple : \"\"\" Returns signature payloads for approve_as_multi \"\"\" nonce = self . get_nonce ( from_address ) approve_as_multi_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , ) return approve_as_multi_payload , nonce arbitrator_nonce def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce as_multi_payload def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , ) return as_multi_payload , nonce broadcast def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) return tx_hash , timepoint , success cancellation def cancellation ( self , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , timepoint : tuple ) -> tuple Return signed and ready transactions for the fee return and escrow return View Source def cancellation ( self , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , timepoint : tuple , ) -> tuple : \"\"\" Return signed and ready transactions for the fee return and escrow return \"\"\" if fee_value > trade_value * 0 . 01 : raise Exception ( \"Fee should not be more than 1% of trade value\" ) nonce = self . arbitrator_nonce () revert_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , timepoint , ) fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) revert_signature = helper . sign_payload ( self . keypair , revert_payload ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) revert_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , revert_signature , nonce , seller_address , trade_value , timepoint , other_signatories , ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce + 1 , seller_address , fee_value , ) return revert_transaction , fee_revert_transaction connect def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () diagnose def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response escrow_payloads def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload , nonce get_balance def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] get_block def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response get_block_hash def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node responce View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node responce \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) ) get_escrow_address def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration (). get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address get_events def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () get_extrinsic_events def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events get_extrinsic_hash def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () ) get_extrinsic_timepoint def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) get_genesis_hash def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] get_mempool_nonce def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce get_metadata def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata get_nonce def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] get_pending_extrinsics def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics get_spec_version def get_spec_version ( self ) -> int Returns the blockchain version View Source def get_spec_version ( self ) -> int : \"\"\" Returns the blockchain version \"\"\" return self . spec_version is_transaction_success def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"approve_as_multi\" and \"NewMultisig\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and \"MultisigExecuted\" in event_names else successful ) return successful publish def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], ) return self . broadcast ( \"transfer\" , transaction ) if type == \"approve_as_multi\" : transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"as_multi\" : transaction = helper . unsigned_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) release_escrow def release_escrow ( self , buyer_address : str , trade_value : int , timepoint : tuple , other_signatories : list ) -> str Return final arbitrator as_multi transaction for releasing escrow View Source def release_escrow ( self , buyer_address : str , trade_value : int , timepoint : tuple , other_signatories : list , ) -> str : \"\"\" Return final arbitrator as_multi transaction for releasing escrow \"\"\" nonce = self . arbitrator_nonce () release_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , buyer_address , trade_value , other_signatories , timepoint , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) release_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , buyer_address , trade_value , timepoint , other_signatories , ) return release_transaction resolve_dispute def resolve_dispute ( self , victor : str , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , welfare_value : int = 1000000000 ) -> tuple If sellers wins then return cancellation logic If buyer wins then return ready approveAsMulti and ready buyer welfare transfer View Source def resolve_dispute ( self , victor : str , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , welfare_value : int = 1000000000 , ) -> tuple : \"\"\" If sellers wins then return cancellation logic If buyer wins then return ready approveAsMulti and ready buyer welfare transfer \"\"\" nonce = self . arbitrator_nonce () if victor == \"seller\" : return self . cancellation ( seller_address , trade_value , fee_value , other_signatories , None ) release_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) welfare_payload = helper . transfer_signature_payload ( self . metadata , seller_address , welfare_value , nonce + 1 , self . genesis_hash , self . spec_version , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) release_transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , seller_address , trade_value , other_signatories , ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce + 1 , seller_address , welfare_value , ) return release_transaction , welfare_transaction runtime_info def runtime_info ( self ) -> int Check the current View Source def runtime_info ( self ) -> int : \"\"\" Check the current \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] setup_arbitrator def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ]. hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], 2 ) transfer_payload def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , ) NonceManager class NonceManager ( / , * args , ** kwargs ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class NonceManager ( ABC ) : \"\"\" Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important \"\"\" @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" ) @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ) : if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce Ancestors (in MRO) abc.ABC Descendants ksmutils.core.Kusama Methods arbitrator_nonce def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce get_mempool_nonce def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce get_nonce def get_nonce ( self , address : str ) -> int View Source @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) get_pending_extrinsics def get_pending_extrinsics ( self ) -> list View Source @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" )","title":"Core"},{"location":"reference/ksmutils/core/#module-ksmutilscore","text":"View Source import logging from abc import ABC from abc import abstractmethod from hashlib import blake2b import sr25519 from scalecodec import ScaleBytes from scalecodec.base import RuntimeConfiguration from scalecodec.base import ScaleDecoder from scalecodec.block import ExtrinsicsDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.type_registry import load_type_registry_preset from scalecodec.utils.ss58 import ss58_decode from scalecodec.utils.ss58 import ss58_encode from . import helper from .network import Network logger = logging . getLogger ( __name__ ) class NonceManager ( ABC ): \"\"\" Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important \"\"\" @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" ) @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce class Kusama ( NonceManager ): def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ): self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], 2 ) def runtime_info ( self ) -> int : \"\"\" Check the current \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ])[ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ) -> int : \"\"\" Returns the blockchain version \"\"\" return self . spec_version def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ] def _get_address_info ( self , address : str ) -> dict : \"\"\" Returns information associated with provided address \"\"\" # Storage key: # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ])[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ])[ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ], 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ]): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key: # xxHash128(System) + xxHash128(Events) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def _get_extrinsic_index ( self , block_extrinsics : list , extrinsic_hash : str ) -> int : \"\"\" Returns the index of a provided extrinsic \"\"\" for idx , extrinsics in enumerate ( block_extrinsics ): ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return - 1 def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ) . digest () . hex () ) def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ) . get ( \"header\" ) . get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ) . get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration () . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , ) def approve_as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list ) -> tuple : \"\"\" Returns signature payloads for approve_as_multi \"\"\" nonce = self . get_nonce ( from_address ) approve_as_multi_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , ) return approve_as_multi_payload , nonce def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , ) return as_multi_payload , nonce def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload , nonce def release_escrow ( self , buyer_address : str , trade_value : int , timepoint : tuple , other_signatories : list , ) -> str : \"\"\" Return final arbitrator as_multi transaction for releasing escrow \"\"\" nonce = self . arbitrator_nonce () release_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , buyer_address , trade_value , other_signatories , timepoint , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) release_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , buyer_address , trade_value , timepoint , other_signatories , ) return release_transaction def cancellation ( self , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , timepoint : tuple , ) -> tuple : \"\"\" Return signed and ready transactions for the fee return and escrow return \"\"\" if fee_value > trade_value * 0.01 : raise Exception ( \"Fee should not be more than 1 % o f trade value\" ) nonce = self . arbitrator_nonce () revert_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , timepoint , ) fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) revert_signature = helper . sign_payload ( self . keypair , revert_payload ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) revert_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , revert_signature , nonce , seller_address , trade_value , timepoint , other_signatories , ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce + 1 , seller_address , fee_value , ) return revert_transaction , fee_revert_transaction def resolve_dispute ( self , victor : str , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , welfare_value : int = 1000000000 , ) -> tuple : \"\"\" If sellers wins then return cancellation logic If buyer wins then return ready approveAsMulti and ready buyer welfare transfer \"\"\" nonce = self . arbitrator_nonce () if victor == \"seller\" : return self . cancellation ( seller_address , trade_value , fee_value , other_signatories , None ) release_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) welfare_payload = helper . transfer_signature_payload ( self . metadata , seller_address , welfare_value , nonce + 1 , self . genesis_hash , self . spec_version , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) release_transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , seller_address , trade_value , other_signatories , ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce + 1 , seller_address , welfare_value , ) return release_transaction , welfare_transaction def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node responce \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {}) . get ( \"result\" , {}) . get ( \"finalized\" ) ) def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"approve_as_multi\" and \"NewMultisig\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and \"MultisigExecuted\" in event_names else successful ) return successful def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], ) return self . broadcast ( \"transfer\" , transaction ) if type == \"approve_as_multi\" : transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"as_multi\" : transaction = helper . unsigned_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ], watch = True ) tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ]) success = self . is_transaction_success ( type , events ) return tx_hash , timepoint , success def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ]) if not getkeys_response . get ( \"result\" , False ): response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ]: storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ])[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , ) response [ item [ 178 :]] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response","title":"Module ksmutils.core"},{"location":"reference/ksmutils/core/#variables","text":"logger","title":"Variables"},{"location":"reference/ksmutils/core/#classes","text":"","title":"Classes"},{"location":"reference/ksmutils/core/#kusama","text":"class Kusama ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' , arbitrator_key : str = None ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class Kusama ( NonceManager ) : def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ) : self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ) : \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key : str ) : \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ] , 2 ) def runtime_info ( self ) -> int : \"\"\" Check the current \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [] ) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ] def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ) -> int : \"\"\" Returns the blockchain version \"\"\" return self . spec_version def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ] ) [ \"result\" ] def _get_address_info ( self , address : str ) -> dict : \"\"\" Returns information associated with provided address \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Account ) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash, None ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash, block_hash ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def _get_extrinsic_index ( self , block_extrinsics : list , extrinsic_hash : str ) -> int : \"\"\" Returns the index of a provided extrinsic \"\"\" for idx , extrinsics in enumerate ( block_extrinsics ) : ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return - 1 def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2: ] ), digest_size = 32 ). digest (). hex () ) def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [] ) [ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration (). get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address, seller_address, self.arbitrator_address ] , 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , ) def approve_as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list ) -> tuple : \"\"\" Returns signature payloads for approve_as_multi \"\"\" nonce = self . get_nonce ( from_address ) approve_as_multi_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , ) return approve_as_multi_payload , nonce def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , ) return as_multi_payload , nonce def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload , nonce def release_escrow ( self , buyer_address : str , trade_value : int , timepoint : tuple , other_signatories : list , ) -> str : \"\"\" Return final arbitrator as_multi transaction for releasing escrow \"\"\" nonce = self . arbitrator_nonce () release_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , buyer_address , trade_value , other_signatories , timepoint , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) release_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , buyer_address , trade_value , timepoint , other_signatories , ) return release_transaction def cancellation ( self , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , timepoint : tuple , ) -> tuple : \"\"\" Return signed and ready transactions for the fee return and escrow return \"\"\" if fee_value > trade_value * 0.01 : raise Exception ( \"Fee should not be more than 1% of trade value\" ) nonce = self . arbitrator_nonce () revert_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , timepoint , ) fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) revert_signature = helper . sign_payload ( self . keypair , revert_payload ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) revert_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , revert_signature , nonce , seller_address , trade_value , timepoint , other_signatories , ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce + 1 , seller_address , fee_value , ) return revert_transaction , fee_revert_transaction def resolve_dispute ( self , victor : str , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , welfare_value : int = 1000000000 , ) -> tuple : \"\"\" If sellers wins then return cancellation logic If buyer wins then return ready approveAsMulti and ready buyer welfare transfer \"\"\" nonce = self . arbitrator_nonce () if victor == \"seller\" : return self . cancellation ( seller_address , trade_value , fee_value , other_signatories , None ) release_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) welfare_payload = helper . transfer_signature_payload ( self . metadata , seller_address , welfare_value , nonce + 1 , self . genesis_hash , self . spec_version , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) release_transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , seller_address , trade_value , other_signatories , ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce + 1 , seller_address , welfare_value , ) return release_transaction , welfare_transaction def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node responce \"\"\" return ( node_response [ max(node_response.keys()) ] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) ) def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ] ) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"approve_as_multi\" and \"NewMultisig\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and \"MultisigExecuted\" in event_names else successful ) return successful def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ] , params [ 1 ] , params [ 2 ] , self . arbitrator_address , params [ 3 ] , ) return self . broadcast ( \"transfer\" , transaction ) if type == \"approve_as_multi\" : transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"as_multi\" : transaction = helper . unsigned_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) return tx_hash , timepoint , success def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response","title":"Kusama"},{"location":"reference/ksmutils/core/#ancestors-in-mro","text":"ksmutils.core.NonceManager abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/ksmutils/core/#methods","text":"","title":"Methods"},{"location":"reference/ksmutils/core/#approve_as_multi_payload","text":"def approve_as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list ) -> tuple Returns signature payloads for approve_as_multi View Source def approve_as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list ) -> tuple : \"\"\" Returns signature payloads for approve_as_multi \"\"\" nonce = self . get_nonce ( from_address ) approve_as_multi_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , ) return approve_as_multi_payload , nonce","title":"approve_as_multi_payload"},{"location":"reference/ksmutils/core/#arbitrator_nonce","text":"def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"arbitrator_nonce"},{"location":"reference/ksmutils/core/#as_multi_payload","text":"def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None ) -> tuple Returns signature payloads for as_multi View Source def as_multi_payload ( self , from_address : str , to_address : str , value : int , other_signatories : list , timepoint : tuple = None , ) -> tuple : \"\"\" Returns signature payloads for as_multi \"\"\" nonce = self . get_nonce ( from_address ) as_multi_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , to_address , value , other_signatories , timepoint , ) return as_multi_payload , nonce","title":"as_multi_payload"},{"location":"reference/ksmutils/core/#broadcast","text":"def broadcast ( self , type : str , transaction : str ) -> tuple Utility function to broadcast complete final transactions View Source def broadcast ( self , type : str , transaction : str ) -> tuple : \"\"\" Utility function to broadcast complete final transactions \"\"\" node_response = self . network . node_rpc_call ( \"author_submitAndWatchExtrinsic\" , [ transaction ] , watch = True ) tx_hash = self . get_extrinsic_hash ( transaction ) block_hash = self . get_block_hash ( node_response ) timepoint = self . get_extrinsic_timepoint ( node_response , transaction ) events = self . get_extrinsic_events ( block_hash , timepoint [ 1 ] ) success = self . is_transaction_success ( type , events ) return tx_hash , timepoint , success","title":"broadcast"},{"location":"reference/ksmutils/core/#cancellation","text":"def cancellation ( self , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , timepoint : tuple ) -> tuple Return signed and ready transactions for the fee return and escrow return View Source def cancellation ( self , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , timepoint : tuple , ) -> tuple : \"\"\" Return signed and ready transactions for the fee return and escrow return \"\"\" if fee_value > trade_value * 0 . 01 : raise Exception ( \"Fee should not be more than 1% of trade value\" ) nonce = self . arbitrator_nonce () revert_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , timepoint , ) fee_revert_payload = helper . transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) revert_signature = helper . sign_payload ( self . keypair , revert_payload ) fee_revert_signature = helper . sign_payload ( self . keypair , fee_revert_payload ) revert_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , revert_signature , nonce , seller_address , trade_value , timepoint , other_signatories , ) fee_revert_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , fee_revert_signature , nonce + 1 , seller_address , fee_value , ) return revert_transaction , fee_revert_transaction","title":"cancellation"},{"location":"reference/ksmutils/core/#connect","text":"def connect ( self , * , node_url : str = '' , network : 'Network' = None ) Connect to a Substrate node and instantiate necessary constants for chain communication View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): \"\"\" Connect to a Substrate node and instantiate necessary constants for chain communication \"\"\" node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network self . runtime_info () RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash ()","title":"connect"},{"location":"reference/ksmutils/core/#diagnose","text":"def diagnose ( self , escrow_address : str ) -> dict Returns details of all unfinished multisigs from an address View Source def diagnose ( self , escrow_address : str ) -> dict : \"\"\" Returns details of all unfinished multisigs from an address \"\"\" response = {} prefix = f \"0x{helper.get_prefix(escrow_address)}\" getkeys_response = self . network . node_rpc_call ( \"state_getKeys\" , [ prefix ] ) if not getkeys_response . get ( \"result\" , False ) : response [ \"status\" ] = \"error getting unfinished escrows\" response [ \"details\" ] = getkeys_response return response for item in getkeys_response [ \"result\" ] : storage_result = self . network . node_rpc_call ( \"state_getStorage\" , [ item ] ) [ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Multisig<BlockNumber, BalanceOf, AccountId>\" , ScaleBytes ( storage_result ), metadata = self . metadata , ) response [ item[178: ] ] = return_decoder . decode () response [ \"status\" ] = \"unfinised escrows found\" return response","title":"diagnose"},{"location":"reference/ksmutils/core/#escrow_payloads","text":"def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address : str , escrow_address : str , trade_value : int , fee_value : int ) -> tuple : \"\"\" Returns signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = helper . transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = helper . transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload , nonce","title":"escrow_payloads"},{"location":"reference/ksmutils/core/#get_balance","text":"def get_balance ( self , address : str ) -> int Returns the free balance associated with provided address View Source def get_balance ( self , address : str ) -> int : \"\"\" Returns the free balance associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ]","title":"get_balance"},{"location":"reference/ksmutils/core/#get_block","text":"def get_block ( self , block_hash : str ) -> dict Returns the block information associated with provided block hash View Source def get_block ( self , block_hash : str ) -> dict : \"\"\" Returns the block information associated with provided block hash \"\"\" response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] ) [ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response","title":"get_block"},{"location":"reference/ksmutils/core/#get_block_hash","text":"def get_block_hash ( self , node_response : dict ) -> str Returns the block hash of a provided node responce View Source def get_block_hash ( self , node_response : dict ) -> str : \"\"\" Returns the block hash of a provided node responce \"\"\" return ( node_response [ max ( node_response . keys ())] . get ( \"params\" , {} ) . get ( \"result\" , {} ) . get ( \"finalized\" ) )","title":"get_block_hash"},{"location":"reference/ksmutils/core/#get_escrow_address","text":"def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address : str , seller_address : str , threshold : int = 2 ) -> str : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration (). get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address","title":"get_escrow_address"},{"location":"reference/ksmutils/core/#get_events","text":"def get_events ( self , block_hash : str ) -> list Returns events broadcasted within the provided block View Source def get_events ( self , block_hash : str ) -> list : \"\"\" Returns events broadcasted within the provided block \"\"\" # Storage key : # xxHash128 ( System ) + xxHash128 ( Events ) storage_hash = ( \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\" ) result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , block_hash ] )[ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"Vec<EventRecord<Event, Hash>>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode ()","title":"get_events"},{"location":"reference/ksmutils/core/#get_extrinsic_events","text":"def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list Returns events triggered by provided extrinsic View Source def get_extrinsic_events ( self , block_hash : str , extrinsinc_index : int ) -> list : \"\"\" Returns events triggered by provided extrinsic \"\"\" events = self . get_events ( block_hash ) extrinsic_events = [] for event in events : if event . get ( \"extrinsic_idx\" ) == extrinsinc_index : extrinsic_events . append ( event ) return extrinsic_events","title":"get_extrinsic_events"},{"location":"reference/ksmutils/core/#get_extrinsic_hash","text":"def get_extrinsic_hash ( self , final_transaction : str ) -> str Returns the extrinsic hash for a provided complete extrinsic View Source def get_extrinsic_hash ( self , final_transaction : str ) -> str : \"\"\" Returns the extrinsic hash for a provided complete extrinsic \"\"\" return ( blake2b ( bytes . fromhex ( final_transaction [ 2 :]), digest_size = 32 ). digest (). hex () )","title":"get_extrinsic_hash"},{"location":"reference/ksmutils/core/#get_extrinsic_timepoint","text":"def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple Returns the timepoint of a provided extrinsic View Source def get_extrinsic_timepoint ( self , node_response : dict , final_transaction : str ) -> tuple : \"\"\" Returns the timepoint of a provided extrinsic \"\"\" if not node_response : raise Exception ( \"node_response is empty\" ) finalized_hash = self . get_block_hash ( node_response ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = self . get_extrinsic_hash ( final_transaction ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsic_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index )","title":"get_extrinsic_timepoint"},{"location":"reference/ksmutils/core/#get_genesis_hash","text":"def get_genesis_hash ( self ) -> str Returns the chain's genesis block hash View Source def get_genesis_hash ( self ) -> str : \"\"\" Returns the chain's genesis block hash \"\"\" return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ])[ \"result\" ]","title":"get_genesis_hash"},{"location":"reference/ksmutils/core/#get_mempool_nonce","text":"def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce","title":"get_mempool_nonce"},{"location":"reference/ksmutils/core/#get_metadata","text":"def get_metadata ( self ) -> 'MetadataDecoder' Returns decoded chain metadata View Source def get_metadata ( self ) -> \"MetadataDecoder\" : \"\"\" Returns decoded chain metadata \"\"\" raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] ) [ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata","title":"get_metadata"},{"location":"reference/ksmutils/core/#get_nonce","text":"def get_nonce ( self , address : str ) -> int Returns the nonce associated with provided address View Source def get_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce associated with provided address \"\"\" result = self . _get_address_info ( address ) return result [ \"nonce\" ]","title":"get_nonce"},{"location":"reference/ksmutils/core/#get_pending_extrinsics","text":"def get_pending_extrinsics ( self ) -> list Returns decoded pending extrinsics View Source def get_pending_extrinsics ( self ) -> list : \"\"\" Returns decoded pending extrinsics \"\"\" decoded_extrinsics = [] extrinsics = self . network . node_rpc_call ( \"author_pendingExtrinsics\" , [])[ \"result\" ] for idx , extrinsic in enumerate ( extrinsics ): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( extrinsic ), metadata = self . metadata ) decoded_extrinsics . append ( extrinsic_decoder . decode ()) return decoded_extrinsics","title":"get_pending_extrinsics"},{"location":"reference/ksmutils/core/#get_spec_version","text":"def get_spec_version ( self ) -> int Returns the blockchain version View Source def get_spec_version ( self ) -> int : \"\"\" Returns the blockchain version \"\"\" return self . spec_version","title":"get_spec_version"},{"location":"reference/ksmutils/core/#is_transaction_success","text":"def is_transaction_success ( self , transaction_type : str , events : list ) -> bool Returns if the a transaction according to the provided events and transaction type View Source def is_transaction_success ( self , transaction_type : str , events : list ) -> bool : \"\"\" Returns if the a transaction according to the provided events and transaction type \"\"\" successful = False event_names = [] for event in events : event_names . append ( event [ \"event_id\" ]) successful = ( True if transaction_type == \"transfer\" and \"Transfer\" in event_names else successful ) successful = ( True if transaction_type == \"approve_as_multi\" and \"NewMultisig\" in event_names else successful ) successful = ( True if transaction_type == \"as_multi\" and \"MultisigExecuted\" in event_names else successful ) return successful","title":"is_transaction_success"},{"location":"reference/ksmutils/core/#publish","text":"def publish ( self , type : str , params : list ) -> tuple Raw extrinsic broadcast View Source def publish ( self , type : str , params : list ) -> tuple : \"\"\" Raw extrinsic broadcast \"\"\" if type == \"transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"fee_transfer\" : transaction = helper . unsigned_transfer_construction ( self . metadata , params [ 0 ], params [ 1 ], params [ 2 ], self . arbitrator_address , params [ 3 ], ) return self . broadcast ( \"transfer\" , transaction ) if type == \"approve_as_multi\" : transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction ) if type == \"as_multi\" : transaction = helper . unsigned_as_multi_construction ( self . metadata , * params ) return self . broadcast ( type , transaction )","title":"publish"},{"location":"reference/ksmutils/core/#release_escrow","text":"def release_escrow ( self , buyer_address : str , trade_value : int , timepoint : tuple , other_signatories : list ) -> str Return final arbitrator as_multi transaction for releasing escrow View Source def release_escrow ( self , buyer_address : str , trade_value : int , timepoint : tuple , other_signatories : list , ) -> str : \"\"\" Return final arbitrator as_multi transaction for releasing escrow \"\"\" nonce = self . arbitrator_nonce () release_payload = helper . as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , buyer_address , trade_value , other_signatories , timepoint , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) release_transaction = helper . unsigned_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , buyer_address , trade_value , timepoint , other_signatories , ) return release_transaction","title":"release_escrow"},{"location":"reference/ksmutils/core/#resolve_dispute","text":"def resolve_dispute ( self , victor : str , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , welfare_value : int = 1000000000 ) -> tuple If sellers wins then return cancellation logic If buyer wins then return ready approveAsMulti and ready buyer welfare transfer View Source def resolve_dispute ( self , victor : str , seller_address : str , trade_value : int , fee_value : int , other_signatories : list , welfare_value : int = 1000000000 , ) -> tuple : \"\"\" If sellers wins then return cancellation logic If buyer wins then return ready approveAsMulti and ready buyer welfare transfer \"\"\" nonce = self . arbitrator_nonce () if victor == \"seller\" : return self . cancellation ( seller_address , trade_value , fee_value , other_signatories , None ) release_payload = helper . approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) welfare_payload = helper . transfer_signature_payload ( self . metadata , seller_address , welfare_value , nonce + 1 , self . genesis_hash , self . spec_version , ) release_signature = helper . sign_payload ( self . keypair , release_payload ) welfare_signature = helper . sign_payload ( self . keypair , welfare_payload ) release_transaction = helper . unsigned_approve_as_multi_construction ( self . metadata , self . arbitrator_address , release_signature , nonce , seller_address , trade_value , other_signatories , ) welfare_transaction = helper . unsigned_transfer_construction ( self . metadata , self . arbitrator_address , welfare_signature , nonce + 1 , seller_address , welfare_value , ) return release_transaction , welfare_transaction","title":"resolve_dispute"},{"location":"reference/ksmutils/core/#runtime_info","text":"def runtime_info ( self ) -> int Check the current View Source def runtime_info ( self ) -> int : \"\"\" Check the current \"\"\" result = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , []) self . spec_version = result [ \"result\" ][ \"specVersion\" ] self . transaction_version = result [ \"result\" ][ \"transactionVersion\" ] return result [ \"result\" ]","title":"runtime_info"},{"location":"reference/ksmutils/core/#setup_arbitrator","text":"def setup_arbitrator ( self , arbitrator_key : str ) Set up constants required for arbitrator functionality View Source def setup_arbitrator ( self , arbitrator_key : str ): \"\"\" Set up constants required for arbitrator functionality \"\"\" self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ]. hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], 2 )","title":"setup_arbitrator"},{"location":"reference/ksmutils/core/#transfer_payload","text":"def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str Returns signature payloads for a regular transfer View Source def transfer_payload ( self , from_address : str , to_address : str , value : int ) -> str : \"\"\" Returns signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return helper . transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , )","title":"transfer_payload"},{"location":"reference/ksmutils/core/#noncemanager","text":"class NonceManager ( / , * args , ** kwargs ) Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important View Source class NonceManager ( ABC ) : \"\"\" Abstract Class: Extending this class allows a user to build advanced nonce management in asyncronous environments where ordering is important \"\"\" @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" ) @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" ) def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ) : if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"NonceManager"},{"location":"reference/ksmutils/core/#ancestors-in-mro_1","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/ksmutils/core/#descendants","text":"ksmutils.core.Kusama","title":"Descendants"},{"location":"reference/ksmutils/core/#methods_1","text":"","title":"Methods"},{"location":"reference/ksmutils/core/#arbitrator_nonce_1","text":"def arbitrator_nonce ( self ) -> int Returns the nonce of any pending extrinsics for the arbitrator View Source def arbitrator_nonce ( self ) -> int : \"\"\" Returns the nonce of any pending extrinsics for the arbitrator \"\"\" if not self . arbitrator_address : raise Exception ( \"Did you forget to setup artitrator address?\" ) mempool_nonce = self . get_mempool_nonce ( self . arbitrator_address ) if mempool_nonce == - 1 : return self . get_nonce ( self . arbitrator_address ) return mempool_nonce","title":"arbitrator_nonce"},{"location":"reference/ksmutils/core/#get_mempool_nonce_1","text":"def get_mempool_nonce ( self , address : str ) -> int Returns the nonce of any pending extrinsics for a given address View Source def get_mempool_nonce ( self , address : str ) -> int : \"\"\" Returns the nonce of any pending extrinsics for a given address \"\"\" account_id = ss58_decode ( address ) pending_extrinsics = self . get_pending_extrinsics () nonce = - 1 for idx , extrinsic in enumerate ( pending_extrinsics ): if extrinsic . get ( \"account_id\" ) == account_id : nonce = max ( extrinsic . get ( \"nonce\" , nonce ), nonce ) return nonce","title":"get_mempool_nonce"},{"location":"reference/ksmutils/core/#get_nonce_1","text":"def get_nonce ( self , address : str ) -> int View Source @abstractmethod def get_nonce ( self , address : str ) -> int : raise NotImplementedError ( \"Not implemented\" )","title":"get_nonce"},{"location":"reference/ksmutils/core/#get_pending_extrinsics_1","text":"def get_pending_extrinsics ( self ) -> list View Source @abstractmethod def get_pending_extrinsics ( self ) -> list : raise NotImplementedError ( \"Not implemented\" )","title":"get_pending_extrinsics"},{"location":"reference/ksmutils/helper/","text":"Module ksmutils.helper Helper functions - all functions in this file are pure with no side effects View Source \"\"\" Helper functions - all functions in this file are pure with no side effects \"\"\" from hashlib import blake2b import scalecodec import sr25519 import xxhash from scalecodec.base import ScaleDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.utils.ss58 import ss58_decode def xx128 ( word : str ) -> str : \"\"\" Returns a xxh128 hash on provided word \"\"\" a = bytearray ( xxhash . xxh64 ( word , seed = 0 ) . digest ()) b = bytearray ( xxhash . xxh64 ( word , seed = 1 ) . digest ()) a . reverse () b . reverse () return f \"{a.hex()}{b.hex()}\" def get_prefix ( escrow_address : str ) -> str : \"\"\" Returns prefix containing the account ID of the address provided \"\"\" module_prefix = xx128 ( \"Multisig\" ) + xx128 ( \"Multisigs\" ) account_id = ss58_decode ( escrow_address , 2 ) storage_key = bytearray ( xxhash . xxh64 ( bytes . fromhex ( account_id ), seed = 0 ) . digest ()) storage_key . reverse () return f \"{module_prefix}{storage_key.hex()}{account_id}\" def hash_call ( call : \"scalecodec.types.Call\" ) -> str : \"\"\" Returns a hashed call \"\"\" call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" def transfer_signature_payload ( metadata : \"MetadataDecoder\" , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def approve_as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned approve_as_multi string \"\"\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) approve_as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : tuple , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned as_multi string \"\"\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def _extrinsic_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , call_function : str , call_module : str , call_arguments : dict , nonce : int , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into extrinsic object \"\"\" extrinsic = ScaleDecoder . get_decoder_class ( \"Extrinsic\" , metadata = metadata ) extrinsic . encode ( { \"account_id\" : account_id , \"signature_version\" : 1 , \"signature\" : signature , \"call_function\" : call_function , \"call_module\" : call_module , \"call_args\" : call_arguments , \"nonce\" : nonce , \"era\" : \"00\" , \"tip\" : tip , } ) return str ( extrinsic . data ) def unsigned_transfer_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into a transfer extrinsic object \"\"\" call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_approve_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , other_signatories , threshold : int = 2 , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into an approve_as_multi extrinsic object \"\"\" call_function = \"approve_as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : tuple , other_signatories : list , threshold : int = 2 , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into an as_multi extrinsic object \"\"\" call_function = \"as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def sign_payload ( keypair : tuple , payload : str ) -> str : \"\"\" Sign payload with keypair and return a signed hex string \"\"\" if payload [ 0 : 2 ] == \"0x\" : payload = payload [ 2 :] signature = sr25519 . sign ( keypair , bytes . fromhex ( payload )) return signature . hex () Functions approve_as_multi_signature_payload def approve_as_multi_signature_payload ( metadata : 'MetadataDecoder' , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 ) -> str Turn parameters gathered through side effects into unsigned approve_as_multi string View Source def approve_as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned approve_as_multi string \"\"\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) approve_as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) as_multi_signature_payload def as_multi_signature_payload ( metadata : 'MetadataDecoder' , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : tuple , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 ) -> str Turn parameters gathered through side effects into unsigned as_multi string View Source def as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : tuple , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned as_multi string \"\"\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) get_prefix def get_prefix ( escrow_address : str ) -> str Returns prefix containing the account ID of the address provided View Source def get_prefix ( escrow_address : str ) -> str : \"\"\" Returns prefix containing the account ID of the address provided \"\"\" module_prefix = xx128 ( \"Multisig\" ) + xx128 ( \"Multisigs\" ) account_id = ss58_decode ( escrow_address , 2 ) storage_key = bytearray ( xxhash . xxh64 ( bytes . fromhex ( account_id ), seed = 0 ). digest ()) storage_key . reverse () return f \"{module_prefix}{storage_key.hex()}{account_id}\" hash_call def hash_call ( call : 'scalecodec.types.Call' ) -> str Returns a hashed call View Source def hash_call ( call : \"scalecodec.types.Call\" ) -> str : \"\"\" Returns a hashed call \"\"\" call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" sign_payload def sign_payload ( keypair : tuple , payload : str ) -> str Sign payload with keypair and return a signed hex string View Source def sign_payload ( keypair : tuple , payload : str ) -> str : \"\"\" Sign payload with keypair and return a signed hex string \"\"\" if payload [ 0 : 2 ] == \"0x\" : payload = payload [ 2 :] signature = sr25519 . sign ( keypair , bytes . fromhex ( payload )) return signature . hex () transfer_signature_payload def transfer_signature_payload ( metadata : 'MetadataDecoder' , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 1 ) -> str Turn parameters gathered through side effects into unsigned transfer string View Source def transfer_signature_payload ( metadata : \"MetadataDecoder\" , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) unsigned_approve_as_multi_construction def unsigned_approve_as_multi_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , other_signatories , threshold : int = 2 , tip : int = 0 ) -> str Turn parameters gathered through side effects into an approve_as_multi extrinsic object View Source def unsigned_approve_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , other_signatories , threshold : int = 2 , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into an approve_as_multi extrinsic object \"\"\" call_function = \"approve_as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) unsigned_as_multi_construction def unsigned_as_multi_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : tuple , other_signatories : list , threshold : int = 2 , tip : int = 0 ) -> str Turn parameters gathered through side effects into an as_multi extrinsic object View Source def unsigned_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : tuple , other_signatories : list , threshold : int = 2 , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into an as_multi extrinsic object \"\"\" call_function = \"as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) unsigned_transfer_construction def unsigned_transfer_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 ) -> str Turn parameters gathered through side effects into a transfer extrinsic object View Source def unsigned_transfer_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into a transfer extrinsic object \"\"\" call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) xx128 def xx128 ( word : str ) -> str Returns a xxh128 hash on provided word View Source def xx128 ( word : str ) -> str : \"\"\" Returns a xxh128 hash on provided word \"\"\" a = bytearray ( xxhash . xxh64 ( word , seed = 0 ). digest ()) b = bytearray ( xxhash . xxh64 ( word , seed = 1 ). digest ()) a . reverse () b . reverse () return f \"{a.hex()}{b.hex()}\"","title":"Helper"},{"location":"reference/ksmutils/helper/#module-ksmutilshelper","text":"Helper functions - all functions in this file are pure with no side effects View Source \"\"\" Helper functions - all functions in this file are pure with no side effects \"\"\" from hashlib import blake2b import scalecodec import sr25519 import xxhash from scalecodec.base import ScaleDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.utils.ss58 import ss58_decode def xx128 ( word : str ) -> str : \"\"\" Returns a xxh128 hash on provided word \"\"\" a = bytearray ( xxhash . xxh64 ( word , seed = 0 ) . digest ()) b = bytearray ( xxhash . xxh64 ( word , seed = 1 ) . digest ()) a . reverse () b . reverse () return f \"{a.hex()}{b.hex()}\" def get_prefix ( escrow_address : str ) -> str : \"\"\" Returns prefix containing the account ID of the address provided \"\"\" module_prefix = xx128 ( \"Multisig\" ) + xx128 ( \"Multisigs\" ) account_id = ss58_decode ( escrow_address , 2 ) storage_key = bytearray ( xxhash . xxh64 ( bytes . fromhex ( account_id ), seed = 0 ) . digest ()) storage_key . reverse () return f \"{module_prefix}{storage_key.hex()}{account_id}\" def hash_call ( call : \"scalecodec.types.Call\" ) -> str : \"\"\" Returns a hashed call \"\"\" call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" def transfer_signature_payload ( metadata : \"MetadataDecoder\" , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def approve_as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned approve_as_multi string \"\"\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) approve_as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : tuple , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned as_multi string \"\"\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def _extrinsic_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , call_function : str , call_module : str , call_arguments : dict , nonce : int , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into extrinsic object \"\"\" extrinsic = ScaleDecoder . get_decoder_class ( \"Extrinsic\" , metadata = metadata ) extrinsic . encode ( { \"account_id\" : account_id , \"signature_version\" : 1 , \"signature\" : signature , \"call_function\" : call_function , \"call_module\" : call_module , \"call_args\" : call_arguments , \"nonce\" : nonce , \"era\" : \"00\" , \"tip\" : tip , } ) return str ( extrinsic . data ) def unsigned_transfer_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into a transfer extrinsic object \"\"\" call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_approve_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , other_signatories , threshold : int = 2 , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into an approve_as_multi extrinsic object \"\"\" call_function = \"approve_as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : tuple , other_signatories : list , threshold : int = 2 , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into an as_multi extrinsic object \"\"\" call_function = \"as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def sign_payload ( keypair : tuple , payload : str ) -> str : \"\"\" Sign payload with keypair and return a signed hex string \"\"\" if payload [ 0 : 2 ] == \"0x\" : payload = payload [ 2 :] signature = sr25519 . sign ( keypair , bytes . fromhex ( payload )) return signature . hex ()","title":"Module ksmutils.helper"},{"location":"reference/ksmutils/helper/#functions","text":"","title":"Functions"},{"location":"reference/ksmutils/helper/#approve_as_multi_signature_payload","text":"def approve_as_multi_signature_payload ( metadata : 'MetadataDecoder' , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 ) -> str Turn parameters gathered through side effects into unsigned approve_as_multi string View Source def approve_as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned approve_as_multi string \"\"\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) approve_as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"approve_as_multi_signature_payload"},{"location":"reference/ksmutils/helper/#as_multi_signature_payload","text":"def as_multi_signature_payload ( metadata : 'MetadataDecoder' , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : tuple , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 ) -> str Turn parameters gathered through side effects into unsigned as_multi string View Source def as_multi_signature_payload ( metadata : \"MetadataDecoder\" , spec_version : int , genesis_hash : str , nonce : int , to_address : str , amount : int , other_signatories : list , timepoint : tuple , threshold : int = 2 , tip : int = 0 , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned as_multi string \"\"\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) as_multi . encode ( { \"call_module\" : \"Multisig\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"as_multi_signature_payload"},{"location":"reference/ksmutils/helper/#get_prefix","text":"def get_prefix ( escrow_address : str ) -> str Returns prefix containing the account ID of the address provided View Source def get_prefix ( escrow_address : str ) -> str : \"\"\" Returns prefix containing the account ID of the address provided \"\"\" module_prefix = xx128 ( \"Multisig\" ) + xx128 ( \"Multisigs\" ) account_id = ss58_decode ( escrow_address , 2 ) storage_key = bytearray ( xxhash . xxh64 ( bytes . fromhex ( account_id ), seed = 0 ). digest ()) storage_key . reverse () return f \"{module_prefix}{storage_key.hex()}{account_id}\"","title":"get_prefix"},{"location":"reference/ksmutils/helper/#hash_call","text":"def hash_call ( call : 'scalecodec.types.Call' ) -> str Returns a hashed call View Source def hash_call ( call : \"scalecodec.types.Call\" ) -> str : \"\"\" Returns a hashed call \"\"\" call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\"","title":"hash_call"},{"location":"reference/ksmutils/helper/#sign_payload","text":"def sign_payload ( keypair : tuple , payload : str ) -> str Sign payload with keypair and return a signed hex string View Source def sign_payload ( keypair : tuple , payload : str ) -> str : \"\"\" Sign payload with keypair and return a signed hex string \"\"\" if payload [ 0 : 2 ] == \"0x\" : payload = payload [ 2 :] signature = sr25519 . sign ( keypair , bytes . fromhex ( payload )) return signature . hex ()","title":"sign_payload"},{"location":"reference/ksmutils/helper/#transfer_signature_payload","text":"def transfer_signature_payload ( metadata : 'MetadataDecoder' , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 1 ) -> str Turn parameters gathered through side effects into unsigned transfer string View Source def transfer_signature_payload ( metadata : \"MetadataDecoder\" , address : str , value : int , nonce : int , genesis_hash : str , spec_version : int , transaction_version : int = 1 , ) -> str : \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"transactionVersion\" : transaction_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"transfer_signature_payload"},{"location":"reference/ksmutils/helper/#unsigned_approve_as_multi_construction","text":"def unsigned_approve_as_multi_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , other_signatories , threshold : int = 2 , tip : int = 0 ) -> str Turn parameters gathered through side effects into an approve_as_multi extrinsic object View Source def unsigned_approve_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , other_signatories , threshold : int = 2 , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into an approve_as_multi extrinsic object \"\"\" call_function = \"approve_as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"unsigned_approve_as_multi_construction"},{"location":"reference/ksmutils/helper/#unsigned_as_multi_construction","text":"def unsigned_as_multi_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : tuple , other_signatories : list , threshold : int = 2 , tip : int = 0 ) -> str Turn parameters gathered through side effects into an as_multi extrinsic object View Source def unsigned_as_multi_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , timepoint : tuple , other_signatories : list , threshold : int = 2 , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into an as_multi extrinsic object \"\"\" call_function = \"as_multi\" call_module = \"Multisig\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"unsigned_as_multi_construction"},{"location":"reference/ksmutils/helper/#unsigned_transfer_construction","text":"def unsigned_transfer_construction ( metadata : 'MetadataDecoder' , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 ) -> str Turn parameters gathered through side effects into a transfer extrinsic object View Source def unsigned_transfer_construction ( metadata : \"MetadataDecoder\" , account_id : str , signature : str , nonce : int , to_address : str , amount : int , tip : int = 0 , ) -> str : \"\"\" Turn parameters gathered through side effects into a transfer extrinsic object \"\"\" call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"unsigned_transfer_construction"},{"location":"reference/ksmutils/helper/#xx128","text":"def xx128 ( word : str ) -> str Returns a xxh128 hash on provided word View Source def xx128 ( word : str ) -> str : \"\"\" Returns a xxh128 hash on provided word \"\"\" a = bytearray ( xxhash . xxh64 ( word , seed = 0 ). digest ()) b = bytearray ( xxhash . xxh64 ( word , seed = 1 ). digest ()) a . reverse () b . reverse () return f \"{a.hex()}{b.hex()}\"","title":"xx128"},{"location":"reference/ksmutils/network/","text":"Module ksmutils.network View Source import asyncio import json import logging import websockets logger = logging . getLogger ( __name__ ) class Network : \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" ): logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution async def _node_rpc_call ( self , method , params , * , loop_limit : int = 0 ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised looping = ( False if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ) else looping ) event_number += 1 await ws_request ( payload ) return ws_results Variables logger Classes Network class Network ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' ) The Network class manages a connection to local/remote Kusama node View Source class Network: \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , *, node_url: str = \"wss://kusama-rpc.polkadot.io/\" ): logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , watch: bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution async def _node_rpc_call ( self , method , params , *, loop_limit: int = 0 ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket: await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping: result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number: result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops: looping = False # End transactions when they are finalised looping = ( False if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ) else looping ) event_number += 1 await ws_request ( payload ) return ws_results Methods node_rpc_call def node_rpc_call ( self , method , params , watch : bool = False ) View Source def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution","title":"Network"},{"location":"reference/ksmutils/network/#module-ksmutilsnetwork","text":"View Source import asyncio import json import logging import websockets logger = logging . getLogger ( __name__ ) class Network : \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" ): logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution async def _node_rpc_call ( self , method , params , * , loop_limit : int = 0 ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised looping = ( False if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ) else looping ) event_number += 1 await ws_request ( payload ) return ws_results","title":"Module ksmutils.network"},{"location":"reference/ksmutils/network/#variables","text":"logger","title":"Variables"},{"location":"reference/ksmutils/network/#classes","text":"","title":"Classes"},{"location":"reference/ksmutils/network/#network","text":"class Network ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' ) The Network class manages a connection to local/remote Kusama node View Source class Network: \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , *, node_url: str = \"wss://kusama-rpc.polkadot.io/\" ): logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , watch: bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution async def _node_rpc_call ( self , method , params , *, loop_limit: int = 0 ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket: await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping: result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number: result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops: looping = False # End transactions when they are finalised looping = ( False if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ) else looping ) event_number += 1 await ws_request ( payload ) return ws_results","title":"Network"},{"location":"reference/ksmutils/network/#methods","text":"","title":"Methods"},{"location":"reference/ksmutils/network/#node_rpc_call","text":"def node_rpc_call ( self , method , params , watch : bool = False ) View Source def node_rpc_call ( self , method , params , watch : bool = False ): logger . info ( \"node_rpc_call for {}\" . format ( method )) execution = ( asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 0 )) if watch else asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = 1 ))[ 0 ] ) return execution","title":"node_rpc_call"},{"location":"reference/ksmutils/settings/","text":"Module ksmutils.settings","title":"Settings"},{"location":"reference/ksmutils/settings/#module-ksmutilssettings","text":"","title":"Module ksmutils.settings"}]}
