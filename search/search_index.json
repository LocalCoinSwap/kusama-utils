{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kusama-utils Kusama utility library providing functionality for multi-signature trading Pre-requisites Python 3.8.1 (preferred) We suggest using pyenv to easily manage python versions. Some of the following commands use pyenv . Use pyenv-installer for easy installation. Then add pyenv-virtualenv plugin to it. Configure local development setup Install and activate python 3.8.1 in the root directory pyenv install 3.8.1 pyenv virtualenv 3.8.1 ksmutils pyenv local ksmutils Install project requirements pip install -r requirements.txt Install precommit hook pre-commit install You're all set to hack! Before making changes, let's ensure tests run successfully on local. Running Tests Run all tests with coverage coverage run -m pytest -v Show report in terminal coverage report -m","title":"Home"},{"location":"#kusama-utils","text":"Kusama utility library providing functionality for multi-signature trading","title":"kusama-utils"},{"location":"#pre-requisites","text":"Python 3.8.1 (preferred) We suggest using pyenv to easily manage python versions. Some of the following commands use pyenv . Use pyenv-installer for easy installation. Then add pyenv-virtualenv plugin to it.","title":"Pre-requisites"},{"location":"#configure-local-development-setup","text":"Install and activate python 3.8.1 in the root directory pyenv install 3.8.1 pyenv virtualenv 3.8.1 ksmutils pyenv local ksmutils Install project requirements pip install -r requirements.txt Install precommit hook pre-commit install You're all set to hack! Before making changes, let's ensure tests run successfully on local.","title":"Configure local development setup"},{"location":"#running-tests","text":"Run all tests with coverage coverage run -m pytest -v Show report in terminal coverage report -m","title":"Running Tests"},{"location":"docs/contributing/1.-local-development/","text":"Local Development Checklist before publishing the package Make sure to update REQUIRED and EXTRAS lists in setup.py based on what's required by the library and what's required only for development. To ease local development, we will continue to maintain requirements.txt which includes every package. Bump the version constant VERSION in setup.py Run setup test python setup.py test Publish package to PyPI python setup.py upload Generating Documentation Generate on local for testing portray server Publishing the docs to https://localcoinswap.github.io/kusama-utils/ Please make sure the docs look as expected on local Checkout to docs-branch branch Only difference between master and docs-branch is that the site/ is not gitignored in docs-branch Rebase docs-branch with master Run portray as_html --overwrite (Read portray docs to know more) That will generate html docs in site/ directory, it will overwrite the existing content Commit the changes and push to docs-branch (Use --force since we rebased with master ) Run this nested git command to publish the changes in gh-pages branch (which serves the static html) git push origin `git subtree split --prefix site docs-branch`:gh-pages --force","title":"1. Local Development"},{"location":"docs/contributing/1.-local-development/#local-development","text":"","title":"Local Development"},{"location":"docs/contributing/1.-local-development/#checklist-before-publishing-the-package","text":"Make sure to update REQUIRED and EXTRAS lists in setup.py based on what's required by the library and what's required only for development. To ease local development, we will continue to maintain requirements.txt which includes every package. Bump the version constant VERSION in setup.py Run setup test python setup.py test Publish package to PyPI python setup.py upload","title":"Checklist before publishing the package"},{"location":"docs/contributing/1.-local-development/#generating-documentation","text":"Generate on local for testing portray server Publishing the docs to https://localcoinswap.github.io/kusama-utils/ Please make sure the docs look as expected on local Checkout to docs-branch branch Only difference between master and docs-branch is that the site/ is not gitignored in docs-branch Rebase docs-branch with master Run portray as_html --overwrite (Read portray docs to know more) That will generate html docs in site/ directory, it will overwrite the existing content Commit the changes and push to docs-branch (Use --force since we rebased with master ) Run this nested git command to publish the changes in gh-pages branch (which serves the static html) git push origin `git subtree split --prefix site docs-branch`:gh-pages --force","title":"Generating Documentation"},{"location":"docs/examples/basic-usage/","text":"Basic setup of the module Instantiating without configuration from ksmutils import Kusama kusama = Kusama () Loading configuration after instantiation from ksmutils import Kusama kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' kusama . setup_arbitrator ( arbitrator_key ) Instantiating with arbitrator and websocket configuration from ksmutils import Kusama kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' node_provider = 'wss://kusama-rpc.polkadot.io/' kusama = Kusama ( arbitrator_key = arbitrator_key , node_url = node_provider ) Connecting to the Kusama blockchain kusama . connect () assert kusama . check_version () == 1062","title":"Basic Usage"},{"location":"docs/examples/basic-usage/#basic-setup-of-the-module","text":"","title":"Basic setup of the module"},{"location":"docs/examples/basic-usage/#instantiating-without-configuration","text":"from ksmutils import Kusama kusama = Kusama ()","title":"Instantiating without configuration"},{"location":"docs/examples/basic-usage/#loading-configuration-after-instantiation","text":"from ksmutils import Kusama kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' kusama . setup_arbitrator ( arbitrator_key )","title":"Loading configuration after instantiation"},{"location":"docs/examples/basic-usage/#instantiating-with-arbitrator-and-websocket-configuration","text":"from ksmutils import Kusama kusama = Kusama () arbitrator_key = 'b5643fe4084cae15ffbbc5c1cbe734bec5da9c351f4aa4d44f2897efeb8375c8' node_provider = 'wss://kusama-rpc.polkadot.io/' kusama = Kusama ( arbitrator_key = arbitrator_key , node_url = node_provider )","title":"Instantiating with arbitrator and websocket configuration"},{"location":"docs/examples/basic-usage/#connecting-to-the-kusama-blockchain","text":"kusama . connect () assert kusama . check_version () == 1062","title":"Connecting to the Kusama blockchain"},{"location":"docs/examples/non-custodial-trades/","text":"Non-custodial trades using the utility module First, setup the module and connect to the Kusama blockchain using the instructions in the basic-usage section. You can now use the library to go through each step of the trading process. Generate an escrow address buyer_address = \"CofvaLbP3m8PLeNRQmLVPWmTT7jGgAXTwyT69k2wkfPxJ9V\" seller_address = \"D2bHQwFcQj11SvtkjULEdKhK4WAeP6MThXgosMHjW9DrmbE\" escrow_address = kusama . get_escrow_address ( buyer_address , seller_address ) Generate the signature payloads to fund the escrow and send the fee trade_value = 10000000000 # Value of the trade in Plancks fee_value = 100000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) escrow_payload , fee_payload = kusama . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value ) Sign the payloads import sr25519 seller_key = '427a2c7cdff26fc2ab1dfda2ba991624cad12f8adc8b0851540db6efec2c7431' keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) escrow_signature = sr25519 . sign ( keypair , bytes . fromhex ( escrow_payload [ 2 :])) fee_signature = sr25519 . sign ( keypair , bytes . fromhex ( fee_payload [ 2 :]))","title":"Non Custodial Trades"},{"location":"docs/examples/non-custodial-trades/#non-custodial-trades-using-the-utility-module","text":"First, setup the module and connect to the Kusama blockchain using the instructions in the basic-usage section. You can now use the library to go through each step of the trading process.","title":"Non-custodial trades using the utility module"},{"location":"docs/examples/non-custodial-trades/#generate-an-escrow-address","text":"buyer_address = \"CofvaLbP3m8PLeNRQmLVPWmTT7jGgAXTwyT69k2wkfPxJ9V\" seller_address = \"D2bHQwFcQj11SvtkjULEdKhK4WAeP6MThXgosMHjW9DrmbE\" escrow_address = kusama . get_escrow_address ( buyer_address , seller_address )","title":"Generate an escrow address"},{"location":"docs/examples/non-custodial-trades/#generate-the-signature-payloads-to-fund-the-escrow-and-send-the-fee","text":"trade_value = 10000000000 # Value of the trade in Plancks fee_value = 100000000 # Fee being paid in Plancks (trade_value is not inclusive of fee) escrow_payload , fee_payload = kusama . escrow_payloads ( seller_address , escrow_address , trade_value , fee_value )","title":"Generate the signature payloads to fund the escrow and send the fee"},{"location":"docs/examples/non-custodial-trades/#sign-the-payloads","text":"import sr25519 seller_key = '427a2c7cdff26fc2ab1dfda2ba991624cad12f8adc8b0851540db6efec2c7431' keypair = sr25519 . pair_from_seed ( bytes . fromhex ( seller_key )) escrow_signature = sr25519 . sign ( keypair , bytes . fromhex ( escrow_payload [ 2 :])) fee_signature = sr25519 . sign ( keypair , bytes . fromhex ( fee_payload [ 2 :]))","title":"Sign the payloads"},{"location":"reference/ksmutils/","text":"Module ksmutils View Source from .core import Kusama from .network import Network __all__ = [ Kusama , Network ] Sub-modules ksmutils.core ksmutils.helper ksmutils.network ksmutils.settings","title":"Index"},{"location":"reference/ksmutils/#module-ksmutils","text":"View Source from .core import Kusama from .network import Network __all__ = [ Kusama , Network ]","title":"Module ksmutils"},{"location":"reference/ksmutils/#sub-modules","text":"ksmutils.core ksmutils.helper ksmutils.network ksmutils.settings","title":"Sub-modules"},{"location":"reference/ksmutils/core/","text":"Module ksmutils.core View Source import logging from hashlib import blake2b import sr25519 from scalecodec import ScaleBytes from scalecodec.base import RuntimeConfiguration from scalecodec.base import ScaleDecoder from scalecodec.block import ExtrinsicsDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.type_registry import load_type_registry_preset from scalecodec.utils.ss58 import ss58_decode from scalecodec.utils.ss58 import ss58_encode from .helper import approve_as_multi_signature_payload from .helper import transfer_signature_payload from .network import Network # Hardcode this because we WANT things to break if it changes BLOCKCHAIN_VERSION = 1062 logger = logging . getLogger ( __name__ ) class Kusama : def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ): self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key ): self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], 2 ) def check_version ( self ): \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [], loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] def get_metadata ( self ): raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ], loop_limit = 1 )[ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ): return BLOCKCHAIN_VERSION def get_genesis_hash ( self ): return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ], loop_limit = 1 )[ 0 ][ \"result\" ] def _get_address_info ( self , address ): # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ], loop_limit = 1 )[ 0 ][ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address ): result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address ): result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash ): # FIXME: Modify node_rpc_call to return single item when there's only one response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ], loop_limit = 1 )[ 0 ][ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ], 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ]): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def _get_extrinsix_index ( self , block_extrinsics , extrinsic_hash ): for idx , extrinsics in enumerate ( block_extrinsics ): ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return 0 def get_extrinsic_timepoint ( self , node_response , extrinsic_data ): if not node_response : raise Exception ( \"node_response is empty\" ) last_item = node_response [ len ( node_response ) - 1 ] finalized_hash = last_item . get ( \"params\" , {}) . get ( \"result\" , {}) . get ( \"finalized\" ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = ( blake2b ( bytes . fromhex ( extrinsic_data [ 2 :]), digest_size = 32 ) . digest () . hex () ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ) . get ( \"header\" ) . get ( \"number\" ) extrinsic_index = self . _get_extrinsix_index ( block . get ( \"block\" ) . get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def broadcast_extrinsic ( self ): \"\"\" Raw extrinsic broadcast \"\"\" pass def broadcast ( self ): \"\"\" Handles final transaction construction according to transaction type \"\"\" pass def transfer_payload ( self , from_address , to_address , value ): \"\"\" Get signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , ) def escrow_payloads ( self , seller_address , escrow_address , trade_value , fee_value ): \"\"\" Get signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload def cancellation ( self , seller_address , trade_value , fee_value , other_signatories ): \"\"\" 1. Broadcast approveAsMulti from arbitrator to seller 2. Verify that the asMulti passed successfully and that the fee is valid 2. Broadcast fee return transfer from arbitrator to seller \"\"\" assert fee_value <= trade_value * 0.01 nonce = self . get_nonce ( self . arbitrator_address ) revert_payload = approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) fee_revert_payload = transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) # TODO: Sign and publish transactions return revert_payload , fee_revert_payload def resolve_dispute ( self ): \"\"\" 1. If sellers wins then use cancellation flow 2. If buyer wins then send broadcast approveAsMulti before sending funds to buyer \"\"\" pass def get_escrow_address ( self , buyer_address , seller_address , threshold = 2 ): \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration () . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address Variables BLOCKCHAIN_VERSION logger Classes Kusama class Kusama ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' , arbitrator_key : str = None ) View Source class Kusama : def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ) : self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ) : node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key ) : self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ] , 2 ) def check_version ( self ) : \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [] , loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] def get_metadata ( self ) : raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ) : return BLOCKCHAIN_VERSION def get_genesis_hash ( self ) : return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ] , loop_limit = 1 ) [ 0 ][ \"result\" ] def _get_address_info ( self , address ) : # xxHash128 ( System ) + xxHash128 ( Account ) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash, None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address ) : result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address ) : result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash ) : # FIXME : Modify node_rpc_call to return single item when there ' s only one response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] , loop_limit = 1 ) [ 0 ][ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def _get_extrinsix_index ( self , block_extrinsics , extrinsic_hash ) : for idx , extrinsics in enumerate ( block_extrinsics ) : ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return 0 def get_extrinsic_timepoint ( self , node_response , extrinsic_data ) : if not node_response : raise Exception ( \"node_response is empty\" ) last_item = node_response [ len(node_response) - 1 ] finalized_hash = last_item . get ( \"params\" , {} ). get ( \"result\" , {} ). get ( \"finalized\" ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = ( blake2b ( bytes . fromhex ( extrinsic_data [ 2: ] ), digest_size = 32 ). digest (). hex () ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsix_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def broadcast_extrinsic ( self ) : \"\"\" Raw extrinsic broadcast \"\"\" pass def broadcast ( self ) : \"\"\" Handles final transaction construction according to transaction type \"\"\" pass def transfer_payload ( self , from_address , to_address , value ) : \"\"\" Get signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , ) def escrow_payloads ( self , seller_address , escrow_address , trade_value , fee_value ) : \"\"\" Get signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload def cancellation ( self , seller_address , trade_value , fee_value , other_signatories ) : \"\"\" 1. Broadcast approveAsMulti from arbitrator to seller 2. Verify that the asMulti passed successfully and that the fee is valid 2. Broadcast fee return transfer from arbitrator to seller \"\"\" assert fee_value <= trade_value * 0.01 nonce = self . get_nonce ( self . arbitrator_address ) revert_payload = approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) fee_revert_payload = transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) # TODO : Sign and publish transactions return revert_payload , fee_revert_payload def resolve_dispute ( self ) : \"\"\" 1. If sellers wins then use cancellation flow 2. If buyer wins then send broadcast approveAsMulti before sending funds to buyer \"\"\" pass def get_escrow_address ( self , buyer_address , seller_address , threshold = 2 ) : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration (). get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address, seller_address, self.arbitrator_address ] , 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address Methods broadcast def broadcast ( self ) Handles final transaction construction according to transaction type View Source def broadcast ( self ): \"\"\" Handles final transaction construction according to transaction type \"\"\" pass broadcast_extrinsic def broadcast_extrinsic ( self ) Raw extrinsic broadcast View Source def broadcast_extrinsic ( self ): \"\"\" Raw extrinsic broadcast \"\"\" pass cancellation def cancellation ( self , seller_address , trade_value , fee_value , other_signatories ) Broadcast approveAsMulti from arbitrator to seller Verify that the asMulti passed successfully and that the fee is valid Broadcast fee return transfer from arbitrator to seller View Source def cancellation ( self , seller_address , trade_value , fee_value , other_signatories ): \"\"\" 1. Broadcast approveAsMulti from arbitrator to seller 2. Verify that the asMulti passed successfully and that the fee is valid 2. Broadcast fee return transfer from arbitrator to seller \"\"\" assert fee_value <= trade_value * 0 . 01 nonce = self . get_nonce ( self . arbitrator_address ) revert_payload = approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) fee_revert_payload = transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) # TODO : Sign and publish transactions return revert_payload , fee_revert_payload check_version def check_version ( self ) Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase View Source def check_version ( self ): \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [], loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] connect def connect ( self , * , node_url : str = '' , network : 'Network' = None ) View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () escrow_payloads def escrow_payloads ( self , seller_address , escrow_address , trade_value , fee_value ) Get signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address , escrow_address , trade_value , fee_value ): \"\"\" Get signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload get_balance def get_balance ( self , address ) View Source def get_balance ( self , address ): result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] get_block def get_block ( self , block_hash ) View Source def get_block ( self , block_hash ) : # FIXME : Modify node_rpc_call to return single item when there ' s only one response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] , loop_limit = 1 ) [ 0 ][ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response get_escrow_address def get_escrow_address ( self , buyer_address , seller_address , threshold = 2 ) Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address , seller_address , threshold = 2 ): \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration (). get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address get_extrinsic_timepoint def get_extrinsic_timepoint ( self , node_response , extrinsic_data ) View Source def get_extrinsic_timepoint ( self , node_response , extrinsic_data ): if not node_response : raise Exception ( \"node_response is empty\" ) last_item = node_response [ len ( node_response ) - 1 ] finalized_hash = last_item . get ( \"params\" , {} ). get ( \"result\" , {} ). get ( \"finalized\" ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = ( blake2b ( bytes . fromhex ( extrinsic_data [ 2 :]), digest_size = 32 ). digest (). hex () ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsix_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) get_genesis_hash def get_genesis_hash ( self ) View Source def get_genesis_hash ( self ): return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ], loop_limit = 1 )[ 0 ][ \"result\" ] get_metadata def get_metadata ( self ) View Source def get_metadata ( self ) : raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata get_nonce def get_nonce ( self , address ) View Source def get_nonce ( self , address ): result = self . _get_address_info ( address ) return result [ \"nonce\" ] get_spec_version def get_spec_version ( self ) View Source def get_spec_version ( self ): return BLOCKCHAIN_VERSION resolve_dispute def resolve_dispute ( self ) If sellers wins then use cancellation flow If buyer wins then send broadcast approveAsMulti before sending funds to buyer View Source def resolve_dispute ( self ): \"\"\" 1. If sellers wins then use cancellation flow 2. If buyer wins then send broadcast approveAsMulti before sending funds to buyer \"\"\" pass setup_arbitrator def setup_arbitrator ( self , arbitrator_key ) View Source def setup_arbitrator ( self , arbitrator_key ): self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ]. hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], 2 ) transfer_payload def transfer_payload ( self , from_address , to_address , value ) Get signature payloads for a regular transfer View Source def transfer_payload ( self , from_address , to_address , value ): \"\"\" Get signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , )","title":"Core"},{"location":"reference/ksmutils/core/#module-ksmutilscore","text":"View Source import logging from hashlib import blake2b import sr25519 from scalecodec import ScaleBytes from scalecodec.base import RuntimeConfiguration from scalecodec.base import ScaleDecoder from scalecodec.block import ExtrinsicsDecoder from scalecodec.metadata import MetadataDecoder from scalecodec.type_registry import load_type_registry_preset from scalecodec.utils.ss58 import ss58_decode from scalecodec.utils.ss58 import ss58_encode from .helper import approve_as_multi_signature_payload from .helper import transfer_signature_payload from .network import Network # Hardcode this because we WANT things to break if it changes BLOCKCHAIN_VERSION = 1062 logger = logging . getLogger ( __name__ ) class Kusama : def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ): self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration () . update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key ): self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], 2 ) def check_version ( self ): \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [], loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] def get_metadata ( self ): raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ], loop_limit = 1 )[ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ): return BLOCKCHAIN_VERSION def get_genesis_hash ( self ): return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ], loop_limit = 1 )[ 0 ][ \"result\" ] def _get_address_info ( self , address ): # xxHash128(System) + xxHash128(Account) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash , None ], loop_limit = 1 )[ 0 ][ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address ): result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address ): result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash ): # FIXME: Modify node_rpc_call to return single item when there's only one response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ], loop_limit = 1 )[ 0 ][ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ], 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ]): extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def _get_extrinsix_index ( self , block_extrinsics , extrinsic_hash ): for idx , extrinsics in enumerate ( block_extrinsics ): ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return 0 def get_extrinsic_timepoint ( self , node_response , extrinsic_data ): if not node_response : raise Exception ( \"node_response is empty\" ) last_item = node_response [ len ( node_response ) - 1 ] finalized_hash = last_item . get ( \"params\" , {}) . get ( \"result\" , {}) . get ( \"finalized\" ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = ( blake2b ( bytes . fromhex ( extrinsic_data [ 2 :]), digest_size = 32 ) . digest () . hex () ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ) . get ( \"header\" ) . get ( \"number\" ) extrinsic_index = self . _get_extrinsix_index ( block . get ( \"block\" ) . get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def broadcast_extrinsic ( self ): \"\"\" Raw extrinsic broadcast \"\"\" pass def broadcast ( self ): \"\"\" Handles final transaction construction according to transaction type \"\"\" pass def transfer_payload ( self , from_address , to_address , value ): \"\"\" Get signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , ) def escrow_payloads ( self , seller_address , escrow_address , trade_value , fee_value ): \"\"\" Get signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload def cancellation ( self , seller_address , trade_value , fee_value , other_signatories ): \"\"\" 1. Broadcast approveAsMulti from arbitrator to seller 2. Verify that the asMulti passed successfully and that the fee is valid 2. Broadcast fee return transfer from arbitrator to seller \"\"\" assert fee_value <= trade_value * 0.01 nonce = self . get_nonce ( self . arbitrator_address ) revert_payload = approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) fee_revert_payload = transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) # TODO: Sign and publish transactions return revert_payload , fee_revert_payload def resolve_dispute ( self ): \"\"\" 1. If sellers wins then use cancellation flow 2. If buyer wins then send broadcast approveAsMulti before sending funds to buyer \"\"\" pass def get_escrow_address ( self , buyer_address , seller_address , threshold = 2 ): \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration () . get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address","title":"Module ksmutils.core"},{"location":"reference/ksmutils/core/#variables","text":"BLOCKCHAIN_VERSION logger","title":"Variables"},{"location":"reference/ksmutils/core/#classes","text":"","title":"Classes"},{"location":"reference/ksmutils/core/#kusama","text":"class Kusama ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' , arbitrator_key : str = None ) View Source class Kusama : def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" , arbitrator_key : str = None , ) : self . node_url = node_url if arbitrator_key : self . setup_arbitrator ( arbitrator_key ) def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ) : node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash () def setup_arbitrator ( self , arbitrator_key ) : self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ] . hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ] , 2 ) def check_version ( self ) : \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [] , loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ] def get_metadata ( self ) : raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata def get_spec_version ( self ) : return BLOCKCHAIN_VERSION def get_genesis_hash ( self ) : return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ] , loop_limit = 1 ) [ 0 ][ \"result\" ] def _get_address_info ( self , address ) : # xxHash128 ( System ) + xxHash128 ( Account ) storage_key = ( \"0x26aa394eea5630e07c48ae0c9558cef7b99d880ec681799c0cf30e8886371da9\" ) account_id = ss58_decode ( address , 2 ) hashed_address = f \"{blake2b(bytes.fromhex(account_id), digest_size=16).digest().hex()}{account_id}\" storage_hash = storage_key + hashed_address result = self . network . node_rpc_call ( \"state_getStorageAt\" , [ storage_hash, None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] return_decoder = ScaleDecoder . get_decoder_class ( \"AccountInfo<Index, AccountData>\" , ScaleBytes ( result ), metadata = self . metadata , ) return return_decoder . decode () def get_balance ( self , address ) : result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ] def get_nonce ( self , address ) : result = self . _get_address_info ( address ) return result [ \"nonce\" ] def get_block ( self , block_hash ) : # FIXME : Modify node_rpc_call to return single item when there ' s only one response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] , loop_limit = 1 ) [ 0 ][ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response def _get_extrinsix_index ( self , block_extrinsics , extrinsic_hash ) : for idx , extrinsics in enumerate ( block_extrinsics ) : ehash = extrinsics . get ( \"extrinsic_hash\" ) if ehash == extrinsic_hash : return idx return 0 def get_extrinsic_timepoint ( self , node_response , extrinsic_data ) : if not node_response : raise Exception ( \"node_response is empty\" ) last_item = node_response [ len(node_response) - 1 ] finalized_hash = last_item . get ( \"params\" , {} ). get ( \"result\" , {} ). get ( \"finalized\" ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = ( blake2b ( bytes . fromhex ( extrinsic_data [ 2: ] ), digest_size = 32 ). digest (). hex () ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsix_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index ) def broadcast_extrinsic ( self ) : \"\"\" Raw extrinsic broadcast \"\"\" pass def broadcast ( self ) : \"\"\" Handles final transaction construction according to transaction type \"\"\" pass def transfer_payload ( self , from_address , to_address , value ) : \"\"\" Get signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , ) def escrow_payloads ( self , seller_address , escrow_address , trade_value , fee_value ) : \"\"\" Get signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload def cancellation ( self , seller_address , trade_value , fee_value , other_signatories ) : \"\"\" 1. Broadcast approveAsMulti from arbitrator to seller 2. Verify that the asMulti passed successfully and that the fee is valid 2. Broadcast fee return transfer from arbitrator to seller \"\"\" assert fee_value <= trade_value * 0.01 nonce = self . get_nonce ( self . arbitrator_address ) revert_payload = approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) fee_revert_payload = transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) # TODO : Sign and publish transactions return revert_payload , fee_revert_payload def resolve_dispute ( self ) : \"\"\" 1. If sellers wins then use cancellation flow 2. If buyer wins then send broadcast approveAsMulti before sending funds to buyer \"\"\" pass def get_escrow_address ( self , buyer_address , seller_address , threshold = 2 ) : \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration (). get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address, seller_address, self.arbitrator_address ] , 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address","title":"Kusama"},{"location":"reference/ksmutils/core/#methods","text":"","title":"Methods"},{"location":"reference/ksmutils/core/#broadcast","text":"def broadcast ( self ) Handles final transaction construction according to transaction type View Source def broadcast ( self ): \"\"\" Handles final transaction construction according to transaction type \"\"\" pass","title":"broadcast"},{"location":"reference/ksmutils/core/#broadcast_extrinsic","text":"def broadcast_extrinsic ( self ) Raw extrinsic broadcast View Source def broadcast_extrinsic ( self ): \"\"\" Raw extrinsic broadcast \"\"\" pass","title":"broadcast_extrinsic"},{"location":"reference/ksmutils/core/#cancellation","text":"def cancellation ( self , seller_address , trade_value , fee_value , other_signatories ) Broadcast approveAsMulti from arbitrator to seller Verify that the asMulti passed successfully and that the fee is valid Broadcast fee return transfer from arbitrator to seller View Source def cancellation ( self , seller_address , trade_value , fee_value , other_signatories ): \"\"\" 1. Broadcast approveAsMulti from arbitrator to seller 2. Verify that the asMulti passed successfully and that the fee is valid 2. Broadcast fee return transfer from arbitrator to seller \"\"\" assert fee_value <= trade_value * 0 . 01 nonce = self . get_nonce ( self . arbitrator_address ) revert_payload = approve_as_multi_signature_payload ( self . metadata , self . spec_version , self . genesis_hash , nonce , seller_address , trade_value , other_signatories , ) fee_revert_payload = transfer_signature_payload ( self . metadata , seller_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) # TODO : Sign and publish transactions return revert_payload , fee_revert_payload","title":"cancellation"},{"location":"reference/ksmutils/core/#check_version","text":"def check_version ( self ) Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase View Source def check_version ( self ): \"\"\" Make sure the versioning of the Kusama blockchain has not been updated since the last developer verification of the codebase \"\"\" version = self . network . node_rpc_call ( \"state_getRuntimeVersion\" , [], loop_limit = 1 ) return version [ 0 ][ \"result\" ][ \"specVersion\" ]","title":"check_version"},{"location":"reference/ksmutils/core/#connect","text":"def connect ( self , * , node_url : str = '' , network : 'Network' = None ) View Source def connect ( self , * , node_url : str = \"\" , network : \"Network\" = None ): node_url = self . node_url if not node_url else node_url if not network : network = Network ( node_url = node_url ) self . network = network assert self . check_version () == BLOCKCHAIN_VERSION RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"default\" ) ) RuntimeConfiguration (). update_type_registry ( load_type_registry_preset ( \"kusama\" )) self . metadata = self . get_metadata () self . spec_version = self . get_spec_version () self . genesis_hash = self . get_genesis_hash ()","title":"connect"},{"location":"reference/ksmutils/core/#escrow_payloads","text":"def escrow_payloads ( self , seller_address , escrow_address , trade_value , fee_value ) Get signature payloads for funding the multisig escrow, and sending the fee to the arbitrator View Source def escrow_payloads ( self , seller_address , escrow_address , trade_value , fee_value ): \"\"\" Get signature payloads for funding the multisig escrow, and sending the fee to the arbitrator \"\"\" nonce = self . get_nonce ( seller_address ) escrow_payload = transfer_signature_payload ( self . metadata , escrow_address , trade_value , nonce , self . genesis_hash , self . spec_version , ) fee_payload = transfer_signature_payload ( self . metadata , self . arbitrator_address , fee_value , nonce + 1 , self . genesis_hash , self . spec_version , ) return escrow_payload , fee_payload","title":"escrow_payloads"},{"location":"reference/ksmutils/core/#get_balance","text":"def get_balance ( self , address ) View Source def get_balance ( self , address ): result = self . _get_address_info ( address ) return result [ \"data\" ][ \"free\" ]","title":"get_balance"},{"location":"reference/ksmutils/core/#get_block","text":"def get_block ( self , block_hash ) View Source def get_block ( self , block_hash ) : # FIXME : Modify node_rpc_call to return single item when there ' s only one response = self . network . node_rpc_call ( \"chain_getBlock\" , [ block_hash ] , loop_limit = 1 ) [ 0 ][ \"result\" ] response [ \"block\" ][ \"header\" ][ \"number\" ] = int ( response [ \"block\" ][ \"header\" ][ \"number\" ] , 16 ) for idx , data in enumerate ( response [ \"block\" ][ \"extrinsics\" ] ) : extrinsic_decoder = ExtrinsicsDecoder ( data = ScaleBytes ( data ), metadata = self . metadata ) extrinsic_decoder . decode () response [ \"block\" ][ \"extrinsics\" ][ idx ] = extrinsic_decoder . value return response","title":"get_block"},{"location":"reference/ksmutils/core/#get_escrow_address","text":"def get_escrow_address ( self , buyer_address , seller_address , threshold = 2 ) Returns an escrow address for multisignature transactions View Source def get_escrow_address ( self , buyer_address , seller_address , threshold = 2 ): \"\"\" Returns an escrow address for multisignature transactions \"\"\" MultiAccountId = RuntimeConfiguration (). get_decoder_class ( \"MultiAccountId\" ) multi_sig_account_id = MultiAccountId . create_from_account_list ( [ buyer_address , seller_address , self . arbitrator_address ], 2 ) multi_sig_address = ss58_encode ( multi_sig_account_id . value . replace ( \"0x\" , \"\" ), 2 ) return multi_sig_address","title":"get_escrow_address"},{"location":"reference/ksmutils/core/#get_extrinsic_timepoint","text":"def get_extrinsic_timepoint ( self , node_response , extrinsic_data ) View Source def get_extrinsic_timepoint ( self , node_response , extrinsic_data ): if not node_response : raise Exception ( \"node_response is empty\" ) last_item = node_response [ len ( node_response ) - 1 ] finalized_hash = last_item . get ( \"params\" , {} ). get ( \"result\" , {} ). get ( \"finalized\" ) if not finalized_hash : raise Exception ( \"Last item in the node_response is not finalized hash\" ) extrinsic_hash = ( blake2b ( bytes . fromhex ( extrinsic_data [ 2 :]), digest_size = 32 ). digest (). hex () ) block = self . get_block ( finalized_hash ) block_number = block . get ( \"block\" ). get ( \"header\" ). get ( \"number\" ) extrinsic_index = self . _get_extrinsix_index ( block . get ( \"block\" ). get ( \"extrinsics\" ), extrinsic_hash ) return ( block_number , extrinsic_index )","title":"get_extrinsic_timepoint"},{"location":"reference/ksmutils/core/#get_genesis_hash","text":"def get_genesis_hash ( self ) View Source def get_genesis_hash ( self ): return self . network . node_rpc_call ( \"chain_getBlockHash\" , [ 0 ], loop_limit = 1 )[ 0 ][ \"result\" ]","title":"get_genesis_hash"},{"location":"reference/ksmutils/core/#get_metadata","text":"def get_metadata ( self ) View Source def get_metadata ( self ) : raw_metadata = self . network . node_rpc_call ( \"state_getMetadata\" , [ None ] , loop_limit = 1 ) [ 0 ][ \"result\" ] metadata = MetadataDecoder ( ScaleBytes ( raw_metadata )) metadata . decode () return metadata","title":"get_metadata"},{"location":"reference/ksmutils/core/#get_nonce","text":"def get_nonce ( self , address ) View Source def get_nonce ( self , address ): result = self . _get_address_info ( address ) return result [ \"nonce\" ]","title":"get_nonce"},{"location":"reference/ksmutils/core/#get_spec_version","text":"def get_spec_version ( self ) View Source def get_spec_version ( self ): return BLOCKCHAIN_VERSION","title":"get_spec_version"},{"location":"reference/ksmutils/core/#resolve_dispute","text":"def resolve_dispute ( self ) If sellers wins then use cancellation flow If buyer wins then send broadcast approveAsMulti before sending funds to buyer View Source def resolve_dispute ( self ): \"\"\" 1. If sellers wins then use cancellation flow 2. If buyer wins then send broadcast approveAsMulti before sending funds to buyer \"\"\" pass","title":"resolve_dispute"},{"location":"reference/ksmutils/core/#setup_arbitrator","text":"def setup_arbitrator ( self , arbitrator_key ) View Source def setup_arbitrator ( self , arbitrator_key ): self . keypair = sr25519 . pair_from_seed ( bytes . fromhex ( arbitrator_key )) self . arbitrator_account_id = self . keypair [ 0 ]. hex () self . arbitrator_address = ss58_encode ( self . keypair [ 0 ], 2 )","title":"setup_arbitrator"},{"location":"reference/ksmutils/core/#transfer_payload","text":"def transfer_payload ( self , from_address , to_address , value ) Get signature payloads for a regular transfer View Source def transfer_payload ( self , from_address , to_address , value ): \"\"\" Get signature payloads for a regular transfer \"\"\" nonce = self . get_nonce ( from_address ) return transfer_signature_payload ( self . metadata , to_address , value , nonce , self . genesis_hash , self . spec_version , )","title":"transfer_payload"},{"location":"reference/ksmutils/helper/","text":"Module ksmutils.helper Helper functions - all functions in this file are pure with no side effects View Source \"\"\" Helper functions - all functions in this file are pure with no side effects \"\"\" from hashlib import blake2b import sr25519 from scalecodec.base import ScaleDecoder def hash_call ( call ): call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ): \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) approve_as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip = 0 , ): extrinsic = ScaleDecoder . get_decoder_class ( \"Extrinsic\" , metadata = metadata ) extrinsic . encode ( { \"account_id\" : account_id , \"signature_version\" : 1 , \"signature\" : signature , \"call_function\" : call_function , \"call_module\" : call_module , \"call_args\" : call_arguments , \"nonce\" : nonce , \"era\" : \"00\" , \"tip\" : tip , } ) return str ( extrinsic . data ) def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ): call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"approve_as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def sign_payload ( payload , signer_public_key , signer_private_key ): \"\"\" TODO: Either validate that 0x is not prefixed or handle both in this function \"\"\" signature = sr25519 . sign ( ( bytes . fromhex ( signer_public_key ), bytes . fromhex ( signer_private_key )), bytes . fromhex ( payload ), ) return f \"0x{signature.hex()}\" Functions approve_as_multi_signature_payload def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 ) View Source def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) approve_as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) as_multi_signature_payload def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 ) View Source def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) hash_call def hash_call ( call ) View Source def hash_call ( call ): call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" sign_payload def sign_payload ( payload , signer_public_key , signer_private_key ) TODO: Either validate that 0x is not prefixed or handle both in this function View Source def sign_payload ( payload , signer_public_key , signer_private_key ): \"\"\" TODO: Either validate that 0x is not prefixed or handle both in this function \"\"\" signature = sr25519 . sign ( ( bytes . fromhex ( signer_public_key ), bytes . fromhex ( signer_private_key )), bytes . fromhex ( payload ), ) return f \"0x{signature.hex()}\" transfer_signature_payload def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ) Turn parameters gathered through side effects into unsigned transfer string View Source def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ): \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) unsigned_approve_as_multi_construction def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 ) View Source def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"approve_as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) unsigned_as_multi_construction def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 ) View Source def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) unsigned_transfer_construction def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ) View Source def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ): call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"Helper"},{"location":"reference/ksmutils/helper/#module-ksmutilshelper","text":"Helper functions - all functions in this file are pure with no side effects View Source \"\"\" Helper functions - all functions in this file are pure with no side effects \"\"\" from hashlib import blake2b import sr25519 from scalecodec.base import ScaleDecoder def hash_call ( call ): call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\" def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ): \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) approve_as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , }, } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data ) def _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip = 0 , ): extrinsic = ScaleDecoder . get_decoder_class ( \"Extrinsic\" , metadata = metadata ) extrinsic . encode ( { \"account_id\" : account_id , \"signature_version\" : 1 , \"signature\" : signature , \"call_function\" : call_function , \"call_module\" : call_module , \"call_args\" : call_arguments , \"nonce\" : nonce , \"era\" : \"00\" , \"tip\" : tip , } ) return str ( extrinsic . data ) def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ): call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"approve_as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount }, } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ]}, \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , ) def sign_payload ( payload , signer_public_key , signer_private_key ): \"\"\" TODO: Either validate that 0x is not prefixed or handle both in this function \"\"\" signature = sr25519 . sign ( ( bytes . fromhex ( signer_public_key ), bytes . fromhex ( signer_private_key )), bytes . fromhex ( payload ), ) return f \"0x{signature.hex()}\"","title":"Module ksmutils.helper"},{"location":"reference/ksmutils/helper/#functions","text":"","title":"Functions"},{"location":"reference/ksmutils/helper/#approve_as_multi_signature_payload","text":"def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 ) View Source def approve_as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) approve_as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) approve_as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"approve_as_multi\" , \"call_args\" : { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( approve_as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"approve_as_multi_signature_payload"},{"location":"reference/ksmutils/helper/#as_multi_signature_payload","text":"def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 ) View Source def as_multi_signature_payload ( metadata , spec_version , genesis_hash , nonce , to_address , amount , other_signatories , timepoint , threshold = 2 , tip = 0 , ): transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) as_multi = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) as_multi . encode ( { \"call_module\" : \"Utility\" , \"call_function\" : \"as_multi\" , \"call_args\" : { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( as_multi . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : tip , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"as_multi_signature_payload"},{"location":"reference/ksmutils/helper/#hash_call","text":"def hash_call ( call ) View Source def hash_call ( call ): call = bytes . fromhex ( str ( call . data )[ 2 :]) return f \"0x{blake2b(call, digest_size=32).digest().hex()}\"","title":"hash_call"},{"location":"reference/ksmutils/helper/#sign_payload","text":"def sign_payload ( payload , signer_public_key , signer_private_key ) TODO: Either validate that 0x is not prefixed or handle both in this function View Source def sign_payload ( payload , signer_public_key , signer_private_key ): \"\"\" TODO: Either validate that 0x is not prefixed or handle both in this function \"\"\" signature = sr25519 . sign ( ( bytes . fromhex ( signer_public_key ), bytes . fromhex ( signer_private_key )), bytes . fromhex ( payload ), ) return f \"0x{signature.hex()}\"","title":"sign_payload"},{"location":"reference/ksmutils/helper/#transfer_signature_payload","text":"def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ) Turn parameters gathered through side effects into unsigned transfer string View Source def transfer_signature_payload ( metadata , address , value , nonce , genesis_hash , spec_version ): \"\"\" Turn parameters gathered through side effects into unsigned transfer string \"\"\" call = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) call . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : address , \"value\" : value } , } ) signature_payload = ScaleDecoder . get_decoder_class ( \"ExtrinsicPayloadValue\" ) signature_payload . encode ( { \"call\" : str ( call . data ), \"era\" : \"00\" , \"nonce\" : nonce , \"tip\" : 0 , \"specVersion\" : spec_version , \"genesisHash\" : genesis_hash , \"blockHash\" : genesis_hash , } ) return str ( signature_payload . data )","title":"transfer_signature_payload"},{"location":"reference/ksmutils/helper/#unsigned_approve_as_multi_construction","text":"def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 ) View Source def unsigned_approve_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"approve_as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call_hash\" : hash_call ( transfer ), \"maybe_timepoint\" : None , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"unsigned_approve_as_multi_construction"},{"location":"reference/ksmutils/helper/#unsigned_as_multi_construction","text":"def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 ) View Source def unsigned_as_multi_construction ( metadata , account_id , signature , nonce , to_address , amount , timepoint , other_signatories , threshold = 2 , tip = 0 , ): call_function = \"as_multi\" call_module = \"Utility\" transfer = ScaleDecoder . get_decoder_class ( \"Call\" , metadata = metadata ) transfer . encode ( { \"call_module\" : \"Balances\" , \"call_function\" : \"transfer\" , \"call_args\" : { \"dest\" : to_address , \"value\" : amount } , } ) call_arguments = { \"call\" : transfer . serialize (), \"maybe_timepoint\" : { \"height\" : timepoint [ 0 ], \"index\" : timepoint [ 1 ] } , \"other_signatories\" : sorted ( other_signatories ), \"threshold\" : threshold , } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"unsigned_as_multi_construction"},{"location":"reference/ksmutils/helper/#unsigned_transfer_construction","text":"def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ) View Source def unsigned_transfer_construction ( metadata , account_id , signature , nonce , to_address , amount , tip = 0 ): call_function = \"transfer\" call_module = \"Balances\" call_arguments = { \"dest\" : to_address , \"value\" : amount } return _extrinsic_construction ( metadata , account_id , signature , call_function , call_module , call_arguments , nonce , tip , )","title":"unsigned_transfer_construction"},{"location":"reference/ksmutils/network/","text":"Module ksmutils.network View Source import asyncio import json import logging import websockets _INSTANCE = None logger = logging . getLogger ( __name__ ) class Network : \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" ): global _INSTANCE assert _INSTANCE is None , \"Network is a singleton!\" _INSTANCE = self logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , * , loop_limit = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit )) async def _node_rpc_call ( self , method , params , * , loop_limit = False ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ): looping = False event_number += 1 await ws_request ( payload ) return ws_results Variables logger Classes Network class Network ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' ) The Network class manages a connection to local/remote Kusama node View Source class Network: \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , *, node_url: str = \"wss://kusama-rpc.polkadot.io/\" ): global _INSTANCE assert _INSTANCE is None , \"Network is a singleton!\" _INSTANCE = self logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , *, loop_limit = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit )) async def _node_rpc_call ( self , method , params , *, loop_limit = False ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket: await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping: result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number: result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops: looping = False # End transactions when they are finalised if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ): looping = False event_number += 1 await ws_request ( payload ) return ws_results Methods node_rpc_call def node_rpc_call ( self , method , params , * , loop_limit = False ) View Source def node_rpc_call ( self , method , params , * , loop_limit = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit ))","title":"Network"},{"location":"reference/ksmutils/network/#module-ksmutilsnetwork","text":"View Source import asyncio import json import logging import websockets _INSTANCE = None logger = logging . getLogger ( __name__ ) class Network : \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , * , node_url : str = \"wss://kusama-rpc.polkadot.io/\" ): global _INSTANCE assert _INSTANCE is None , \"Network is a singleton!\" _INSTANCE = self logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , * , loop_limit = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit )) async def _node_rpc_call ( self , method , params , * , loop_limit = False ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket : await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping : result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number : result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops : looping = False # End transactions when they are finalised if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ): looping = False event_number += 1 await ws_request ( payload ) return ws_results","title":"Module ksmutils.network"},{"location":"reference/ksmutils/network/#variables","text":"logger","title":"Variables"},{"location":"reference/ksmutils/network/#classes","text":"","title":"Classes"},{"location":"reference/ksmutils/network/#network","text":"class Network ( * , node_url : str = 'wss://kusama-rpc.polkadot.io/' ) The Network class manages a connection to local/remote Kusama node View Source class Network: \"\"\" The Network class manages a connection to local/remote Kusama node \"\"\" def __init__ ( self , *, node_url: str = \"wss://kusama-rpc.polkadot.io/\" ): global _INSTANCE assert _INSTANCE is None , \"Network is a singleton!\" _INSTANCE = self logger . info ( f \"Instantiating network connection to {node_url}\" ) self . node_url = node_url def node_rpc_call ( self , method , params , *, loop_limit = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit )) async def _node_rpc_call ( self , method , params , *, loop_limit = False ): \"\"\" Generic method for node RPC calls. It's important to set loop_limit to 1 if you are not pushing transactions or you will get an infinite loop \"\"\" payload = { \"jsonrpc\" : \"2.0\" , \"method\" : method , \"params\" : params , \"id\" : 1 , } ws_results = {} async def ws_request ( payload ): async with websockets . connect ( self . node_url ) as websocket: await websocket . send ( json . dumps ( payload )) event_number = 0 loops = 0 looping = True while looping: result = json . loads ( await websocket . recv ()) # logger.info(f\"Received from server {result}\") ws_results . update ({ event_number: result }) # Kill things immediately for simple requests loops += 1 if loop_limit and loop_limit <= loops: looping = False # End transactions when they are finalised if ( \"params\" in result and type ( result [ \"params\" ][ \"result\" ]) is dict and \"finalized\" in result [ \"params\" ][ \"result\" ] ): looping = False event_number += 1 await ws_request ( payload ) return ws_results","title":"Network"},{"location":"reference/ksmutils/network/#methods","text":"","title":"Methods"},{"location":"reference/ksmutils/network/#node_rpc_call","text":"def node_rpc_call ( self , method , params , * , loop_limit = False ) View Source def node_rpc_call ( self , method , params , * , loop_limit = False ): return asyncio . run ( self . _node_rpc_call ( method , params , loop_limit = loop_limit ))","title":"node_rpc_call"},{"location":"reference/ksmutils/settings/","text":"Module ksmutils.settings","title":"Settings"},{"location":"reference/ksmutils/settings/#module-ksmutilssettings","text":"","title":"Module ksmutils.settings"}]}
